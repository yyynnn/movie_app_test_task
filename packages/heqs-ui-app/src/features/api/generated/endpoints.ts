/**
 * Generated by orval v6.10.3 üç∫
 * Do not edit manually.
 * OpenApi Documentation
 * –î–æ–∫—É–º–µ–Ω—Ç–∞—Ü–∏—è –¥–ª—è –º–∏–∫—Ä–æ —Å–µ—Ä–≤–∏—Å–∞
 * OpenAPI spec version: 1.0.0
 */
import type {
  MutationFunction,
  QueryFunction,
  QueryKey,
  UseMutationOptions,
  UseQueryOptions,
  UseQueryResult
} from '@tanstack/react-query'
import { useMutation, useQuery } from '@tanstack/react-query'
import type { AxiosError, AxiosRequestConfig, AxiosResponse } from 'axios'
import axios from 'axios'

import type {
  AccidentsStatParams,
  AuditFindingsClosureStatParams,
  CorrectiveAction,
  CorrectiveActionImplementationStatParams,
  Factory,
  GetPaginatedCorrectiveActionListParams,
  GetPaginatedTicketListParams,
  Login200,
  Login422,
  LoginBody,
  Logout200,
  Register200,
  Register422,
  RegisterBody,
  Ticket,
  User,
  UserPosition,
  Workcenter,
  WorkcentersStatParams,
  WorkcentersTicketStatusesStaticticsParams
} from './models'

/**
 * –ü–æ–ª—É—á–µ–Ω–∏–µ –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏–∏ –æ –Ω–∞—Å—Ç—Ä–æ–π–∫–∞—Ö php –Ω–∞ —Å–µ—Ä–≤–µ—Ä–µ
 * @summary –ü–æ–ª—É—á–µ–Ω–∏–µ –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏–∏ –æ –Ω–∞—Å—Ç—Ä–æ–π–∫–∞—Ö php –Ω–∞ —Å–µ—Ä–≤–µ—Ä–µ
 */
export const php = (options?: AxiosRequestConfig): Promise<AxiosResponse<void>> => {
  return axios.get(`/php`, options)
}

export const getPhpQueryKey = () => [`/php`]

export type PhpQueryResult = NonNullable<Awaited<ReturnType<typeof php>>>
export type PhpQueryError = AxiosError<unknown>

export const usePhp = <
  TData = Awaited<ReturnType<typeof php>>,
  TError = AxiosError<unknown>
>(options?: {
  query?: UseQueryOptions<Awaited<ReturnType<typeof php>>, TError, TData>
  axios?: AxiosRequestConfig
}): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {
  const { query: queryOptions, axios: axiosOptions } = options ?? {}

  const queryKey = queryOptions?.queryKey ?? getPhpQueryKey()

  const queryFn: QueryFunction<Awaited<ReturnType<typeof php>>> = ({ signal }) =>
    php({ signal, ...axiosOptions })

  const query = useQuery<Awaited<ReturnType<typeof php>>, TError, TData>(
    queryKey,
    queryFn,
    queryOptions
  ) as UseQueryResult<TData, TError> & { queryKey: QueryKey }

  query.queryKey = queryKey

  return query
}

/**
 * @summary Get Paginated Corrective Action List
 */
export const getPaginatedCorrectiveActionList = (
  params?: GetPaginatedCorrectiveActionListParams,
  options?: AxiosRequestConfig
): Promise<AxiosResponse<void>> => {
  return axios.get(`/corretcive_actions`, {
    ...options,
    params: { ...params, ...options?.params }
  })
}

export const getGetPaginatedCorrectiveActionListQueryKey = (
  params?: GetPaginatedCorrectiveActionListParams
) => [`/corretcive_actions`, ...(params ? [params] : [])]

export type GetPaginatedCorrectiveActionListQueryResult = NonNullable<
  Awaited<ReturnType<typeof getPaginatedCorrectiveActionList>>
>
export type GetPaginatedCorrectiveActionListQueryError = AxiosError<unknown>

export const useGetPaginatedCorrectiveActionList = <
  TData = Awaited<ReturnType<typeof getPaginatedCorrectiveActionList>>,
  TError = AxiosError<unknown>
>(
  params?: GetPaginatedCorrectiveActionListParams,
  options?: {
    query?: UseQueryOptions<
      Awaited<ReturnType<typeof getPaginatedCorrectiveActionList>>,
      TError,
      TData
    >
    axios?: AxiosRequestConfig
  }
): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {
  const { query: queryOptions, axios: axiosOptions } = options ?? {}

  const queryKey = queryOptions?.queryKey ?? getGetPaginatedCorrectiveActionListQueryKey(params)

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getPaginatedCorrectiveActionList>>> = ({
    signal
  }) => getPaginatedCorrectiveActionList(params, { signal, ...axiosOptions })

  const query = useQuery<
    Awaited<ReturnType<typeof getPaginatedCorrectiveActionList>>,
    TError,
    TData
  >(queryKey, queryFn, queryOptions) as UseQueryResult<TData, TError> & { queryKey: QueryKey }

  query.queryKey = queryKey

  return query
}

/**
 * @summary Create New Corretcive Action
 */
export const createNewCorretciveAction = (
  correctiveAction: CorrectiveAction,
  options?: AxiosRequestConfig
): Promise<AxiosResponse<void>> => {
  return axios.post(`/corretcive_actions`, correctiveAction, options)
}

export type CreateNewCorretciveActionMutationResult = NonNullable<
  Awaited<ReturnType<typeof createNewCorretciveAction>>
>
export type CreateNewCorretciveActionMutationBody = CorrectiveAction
export type CreateNewCorretciveActionMutationError = AxiosError<unknown>

export const useCreateNewCorretciveAction = <
  TError = AxiosError<unknown>,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof createNewCorretciveAction>>,
    TError,
    { data: CorrectiveAction },
    TContext
  >
  axios?: AxiosRequestConfig
}) => {
  const { mutation: mutationOptions, axios: axiosOptions } = options ?? {}

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof createNewCorretciveAction>>,
    { data: CorrectiveAction }
  > = (props) => {
    const { data } = props ?? {}

    return createNewCorretciveAction(data, axiosOptions)
  }

  return useMutation<
    Awaited<ReturnType<typeof createNewCorretciveAction>>,
    TError,
    { data: CorrectiveAction },
    TContext
  >(mutationFn, mutationOptions)
}

/**
 * @summary Read Corretcive Action By ID
 */
export const readCorretciveActionByID = (
  corretciveActionId: number,
  options?: AxiosRequestConfig
): Promise<AxiosResponse<CorrectiveAction>> => {
  return axios.get(`/corretcive_actions/${corretciveActionId}`, options)
}

export const getReadCorretciveActionByIDQueryKey = (corretciveActionId: number) => [
  `/corretcive_actions/${corretciveActionId}`
]

export type ReadCorretciveActionByIDQueryResult = NonNullable<
  Awaited<ReturnType<typeof readCorretciveActionByID>>
>
export type ReadCorretciveActionByIDQueryError = AxiosError<unknown>

export const useReadCorretciveActionByID = <
  TData = Awaited<ReturnType<typeof readCorretciveActionByID>>,
  TError = AxiosError<unknown>
>(
  corretciveActionId: number,
  options?: {
    query?: UseQueryOptions<Awaited<ReturnType<typeof readCorretciveActionByID>>, TError, TData>
    axios?: AxiosRequestConfig
  }
): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {
  const { query: queryOptions, axios: axiosOptions } = options ?? {}

  const queryKey = queryOptions?.queryKey ?? getReadCorretciveActionByIDQueryKey(corretciveActionId)

  const queryFn: QueryFunction<Awaited<ReturnType<typeof readCorretciveActionByID>>> = ({
    signal
  }) => readCorretciveActionByID(corretciveActionId, { signal, ...axiosOptions })

  const query = useQuery<Awaited<ReturnType<typeof readCorretciveActionByID>>, TError, TData>(
    queryKey,
    queryFn,
    { enabled: !!corretciveActionId, ...queryOptions }
  ) as UseQueryResult<TData, TError> & { queryKey: QueryKey }

  query.queryKey = queryKey

  return query
}

/**
 * @summary Update Corretcive Action By ID
 */
export const updateCorretciveActionByID = (
  corretciveActionId: number,
  correctiveAction: CorrectiveAction,
  options?: AxiosRequestConfig
): Promise<AxiosResponse<CorrectiveAction>> => {
  return axios.put(`/corretcive_actions/${corretciveActionId}`, correctiveAction, options)
}

export type UpdateCorretciveActionByIDMutationResult = NonNullable<
  Awaited<ReturnType<typeof updateCorretciveActionByID>>
>
export type UpdateCorretciveActionByIDMutationBody = CorrectiveAction
export type UpdateCorretciveActionByIDMutationError = AxiosError<unknown>

export const useUpdateCorretciveActionByID = <
  TError = AxiosError<unknown>,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof updateCorretciveActionByID>>,
    TError,
    { corretciveActionId: number; data: CorrectiveAction },
    TContext
  >
  axios?: AxiosRequestConfig
}) => {
  const { mutation: mutationOptions, axios: axiosOptions } = options ?? {}

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof updateCorretciveActionByID>>,
    { corretciveActionId: number; data: CorrectiveAction }
  > = (props) => {
    const { corretciveActionId, data } = props ?? {}

    return updateCorretciveActionByID(corretciveActionId, data, axiosOptions)
  }

  return useMutation<
    Awaited<ReturnType<typeof updateCorretciveActionByID>>,
    TError,
    { corretciveActionId: number; data: CorrectiveAction },
    TContext
  >(mutationFn, mutationOptions)
}

/**
 * @summary Delete Corretcive Action By ID
 */
export const deleteCorretciveActionByID = (
  corretciveActionId: number,
  options?: AxiosRequestConfig
): Promise<AxiosResponse<void>> => {
  return axios.delete(`/corretcive_actions/${corretciveActionId}`, options)
}

export type DeleteCorretciveActionByIDMutationResult = NonNullable<
  Awaited<ReturnType<typeof deleteCorretciveActionByID>>
>

export type DeleteCorretciveActionByIDMutationError = AxiosError<unknown>

export const useDeleteCorretciveActionByID = <
  TError = AxiosError<unknown>,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof deleteCorretciveActionByID>>,
    TError,
    { corretciveActionId: number },
    TContext
  >
  axios?: AxiosRequestConfig
}) => {
  const { mutation: mutationOptions, axios: axiosOptions } = options ?? {}

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof deleteCorretciveActionByID>>,
    { corretciveActionId: number }
  > = (props) => {
    const { corretciveActionId } = props ?? {}

    return deleteCorretciveActionByID(corretciveActionId, axiosOptions)
  }

  return useMutation<
    Awaited<ReturnType<typeof deleteCorretciveActionByID>>,
    TError,
    { corretciveActionId: number },
    TContext
  >(mutationFn, mutationOptions)
}

/**
 * @summary Get ticket_classes dictionary
 */
export const getTicketClassesDictionary = (
  options?: AxiosRequestConfig
): Promise<AxiosResponse<void>> => {
  return axios.get(`/dictionary/ticket_classes`, options)
}

export const getGetTicketClassesDictionaryQueryKey = () => [`/dictionary/ticket_classes`]

export type GetTicketClassesDictionaryQueryResult = NonNullable<
  Awaited<ReturnType<typeof getTicketClassesDictionary>>
>
export type GetTicketClassesDictionaryQueryError = AxiosError<unknown>

export const useGetTicketClassesDictionary = <
  TData = Awaited<ReturnType<typeof getTicketClassesDictionary>>,
  TError = AxiosError<unknown>
>(options?: {
  query?: UseQueryOptions<Awaited<ReturnType<typeof getTicketClassesDictionary>>, TError, TData>
  axios?: AxiosRequestConfig
}): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {
  const { query: queryOptions, axios: axiosOptions } = options ?? {}

  const queryKey = queryOptions?.queryKey ?? getGetTicketClassesDictionaryQueryKey()

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getTicketClassesDictionary>>> = ({
    signal
  }) => getTicketClassesDictionary({ signal, ...axiosOptions })

  const query = useQuery<Awaited<ReturnType<typeof getTicketClassesDictionary>>, TError, TData>(
    queryKey,
    queryFn,
    queryOptions
  ) as UseQueryResult<TData, TError> & { queryKey: QueryKey }

  query.queryKey = queryKey

  return query
}

/**
 * @summary Get ticket_categories dictionary
 */
export const getTicketCategoriesDictionary = (
  options?: AxiosRequestConfig
): Promise<AxiosResponse<void>> => {
  return axios.get(`/dictionary/ticket_categories`, options)
}

export const getGetTicketCategoriesDictionaryQueryKey = () => [`/dictionary/ticket_categories`]

export type GetTicketCategoriesDictionaryQueryResult = NonNullable<
  Awaited<ReturnType<typeof getTicketCategoriesDictionary>>
>
export type GetTicketCategoriesDictionaryQueryError = AxiosError<unknown>

export const useGetTicketCategoriesDictionary = <
  TData = Awaited<ReturnType<typeof getTicketCategoriesDictionary>>,
  TError = AxiosError<unknown>
>(options?: {
  query?: UseQueryOptions<Awaited<ReturnType<typeof getTicketCategoriesDictionary>>, TError, TData>
  axios?: AxiosRequestConfig
}): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {
  const { query: queryOptions, axios: axiosOptions } = options ?? {}

  const queryKey = queryOptions?.queryKey ?? getGetTicketCategoriesDictionaryQueryKey()

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getTicketCategoriesDictionary>>> = ({
    signal
  }) => getTicketCategoriesDictionary({ signal, ...axiosOptions })

  const query = useQuery<Awaited<ReturnType<typeof getTicketCategoriesDictionary>>, TError, TData>(
    queryKey,
    queryFn,
    queryOptions
  ) as UseQueryResult<TData, TError> & { queryKey: QueryKey }

  query.queryKey = queryKey

  return query
}

/**
 * @summary Get ticket_statuses dictionary
 */
export const getTicketStatusesDictionary = (
  options?: AxiosRequestConfig
): Promise<AxiosResponse<void>> => {
  return axios.get(`/dictionary/ticket_statuses`, options)
}

export const getGetTicketStatusesDictionaryQueryKey = () => [`/dictionary/ticket_statuses`]

export type GetTicketStatusesDictionaryQueryResult = NonNullable<
  Awaited<ReturnType<typeof getTicketStatusesDictionary>>
>
export type GetTicketStatusesDictionaryQueryError = AxiosError<unknown>

export const useGetTicketStatusesDictionary = <
  TData = Awaited<ReturnType<typeof getTicketStatusesDictionary>>,
  TError = AxiosError<unknown>
>(options?: {
  query?: UseQueryOptions<Awaited<ReturnType<typeof getTicketStatusesDictionary>>, TError, TData>
  axios?: AxiosRequestConfig
}): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {
  const { query: queryOptions, axios: axiosOptions } = options ?? {}

  const queryKey = queryOptions?.queryKey ?? getGetTicketStatusesDictionaryQueryKey()

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getTicketStatusesDictionary>>> = ({
    signal
  }) => getTicketStatusesDictionary({ signal, ...axiosOptions })

  const query = useQuery<Awaited<ReturnType<typeof getTicketStatusesDictionary>>, TError, TData>(
    queryKey,
    queryFn,
    queryOptions
  ) as UseQueryResult<TData, TError> & { queryKey: QueryKey }

  query.queryKey = queryKey

  return query
}

/**
 * @summary Get corrective_action_statuses dictionary
 */
export const getCorrectiveActionStatusesDictionary = (
  options?: AxiosRequestConfig
): Promise<AxiosResponse<void>> => {
  return axios.get(`/dictionary/corrective_action_statuses`, options)
}

export const getGetCorrectiveActionStatusesDictionaryQueryKey = () => [
  `/dictionary/corrective_action_statuses`
]

export type GetCorrectiveActionStatusesDictionaryQueryResult = NonNullable<
  Awaited<ReturnType<typeof getCorrectiveActionStatusesDictionary>>
>
export type GetCorrectiveActionStatusesDictionaryQueryError = AxiosError<unknown>

export const useGetCorrectiveActionStatusesDictionary = <
  TData = Awaited<ReturnType<typeof getCorrectiveActionStatusesDictionary>>,
  TError = AxiosError<unknown>
>(options?: {
  query?: UseQueryOptions<
    Awaited<ReturnType<typeof getCorrectiveActionStatusesDictionary>>,
    TError,
    TData
  >
  axios?: AxiosRequestConfig
}): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {
  const { query: queryOptions, axios: axiosOptions } = options ?? {}

  const queryKey = queryOptions?.queryKey ?? getGetCorrectiveActionStatusesDictionaryQueryKey()

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getCorrectiveActionStatusesDictionary>>
  > = ({ signal }) => getCorrectiveActionStatusesDictionary({ signal, ...axiosOptions })

  const query = useQuery<
    Awaited<ReturnType<typeof getCorrectiveActionStatusesDictionary>>,
    TError,
    TData
  >(queryKey, queryFn, queryOptions) as UseQueryResult<TData, TError> & { queryKey: QueryKey }

  query.queryKey = queryKey

  return query
}

/**
 * @summary Get root_causes dictionary
 */
export const getRootCausesDictionary = (
  options?: AxiosRequestConfig
): Promise<AxiosResponse<void>> => {
  return axios.get(`/dictionary/root_causes`, options)
}

export const getGetRootCausesDictionaryQueryKey = () => [`/dictionary/root_causes`]

export type GetRootCausesDictionaryQueryResult = NonNullable<
  Awaited<ReturnType<typeof getRootCausesDictionary>>
>
export type GetRootCausesDictionaryQueryError = AxiosError<unknown>

export const useGetRootCausesDictionary = <
  TData = Awaited<ReturnType<typeof getRootCausesDictionary>>,
  TError = AxiosError<unknown>
>(options?: {
  query?: UseQueryOptions<Awaited<ReturnType<typeof getRootCausesDictionary>>, TError, TData>
  axios?: AxiosRequestConfig
}): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {
  const { query: queryOptions, axios: axiosOptions } = options ?? {}

  const queryKey = queryOptions?.queryKey ?? getGetRootCausesDictionaryQueryKey()

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getRootCausesDictionary>>> = ({
    signal
  }) => getRootCausesDictionary({ signal, ...axiosOptions })

  const query = useQuery<Awaited<ReturnType<typeof getRootCausesDictionary>>, TError, TData>(
    queryKey,
    queryFn,
    queryOptions
  ) as UseQueryResult<TData, TError> & { queryKey: QueryKey }

  query.queryKey = queryKey

  return query
}

/**
 * @summary Get countries dictionary
 */
export const getCountriesDictionary = (
  options?: AxiosRequestConfig
): Promise<AxiosResponse<void>> => {
  return axios.get(`/dictionary/countries`, options)
}

export const getGetCountriesDictionaryQueryKey = () => [`/dictionary/countries`]

export type GetCountriesDictionaryQueryResult = NonNullable<
  Awaited<ReturnType<typeof getCountriesDictionary>>
>
export type GetCountriesDictionaryQueryError = AxiosError<unknown>

export const useGetCountriesDictionary = <
  TData = Awaited<ReturnType<typeof getCountriesDictionary>>,
  TError = AxiosError<unknown>
>(options?: {
  query?: UseQueryOptions<Awaited<ReturnType<typeof getCountriesDictionary>>, TError, TData>
  axios?: AxiosRequestConfig
}): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {
  const { query: queryOptions, axios: axiosOptions } = options ?? {}

  const queryKey = queryOptions?.queryKey ?? getGetCountriesDictionaryQueryKey()

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getCountriesDictionary>>> = ({ signal }) =>
    getCountriesDictionary({ signal, ...axiosOptions })

  const query = useQuery<Awaited<ReturnType<typeof getCountriesDictionary>>, TError, TData>(
    queryKey,
    queryFn,
    queryOptions
  ) as UseQueryResult<TData, TError> & { queryKey: QueryKey }

  query.queryKey = queryKey

  return query
}

/**
 * @summary Get factories dictionary
 */
export const getFactoriesDictionary = (
  options?: AxiosRequestConfig
): Promise<AxiosResponse<void>> => {
  return axios.get(`/dictionary/factories`, options)
}

export const getGetFactoriesDictionaryQueryKey = () => [`/dictionary/factories`]

export type GetFactoriesDictionaryQueryResult = NonNullable<
  Awaited<ReturnType<typeof getFactoriesDictionary>>
>
export type GetFactoriesDictionaryQueryError = AxiosError<unknown>

export const useGetFactoriesDictionary = <
  TData = Awaited<ReturnType<typeof getFactoriesDictionary>>,
  TError = AxiosError<unknown>
>(options?: {
  query?: UseQueryOptions<Awaited<ReturnType<typeof getFactoriesDictionary>>, TError, TData>
  axios?: AxiosRequestConfig
}): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {
  const { query: queryOptions, axios: axiosOptions } = options ?? {}

  const queryKey = queryOptions?.queryKey ?? getGetFactoriesDictionaryQueryKey()

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getFactoriesDictionary>>> = ({ signal }) =>
    getFactoriesDictionary({ signal, ...axiosOptions })

  const query = useQuery<Awaited<ReturnType<typeof getFactoriesDictionary>>, TError, TData>(
    queryKey,
    queryFn,
    queryOptions
  ) as UseQueryResult<TData, TError> & { queryKey: QueryKey }

  query.queryKey = queryKey

  return query
}

/**
 * @summary Get workcenter_groups dictionary
 */
export const getWorkcenterGroupsDictionary = (
  options?: AxiosRequestConfig
): Promise<AxiosResponse<void>> => {
  return axios.get(`/dictionary/workcenter_groups`, options)
}

export const getGetWorkcenterGroupsDictionaryQueryKey = () => [`/dictionary/workcenter_groups`]

export type GetWorkcenterGroupsDictionaryQueryResult = NonNullable<
  Awaited<ReturnType<typeof getWorkcenterGroupsDictionary>>
>
export type GetWorkcenterGroupsDictionaryQueryError = AxiosError<unknown>

export const useGetWorkcenterGroupsDictionary = <
  TData = Awaited<ReturnType<typeof getWorkcenterGroupsDictionary>>,
  TError = AxiosError<unknown>
>(options?: {
  query?: UseQueryOptions<Awaited<ReturnType<typeof getWorkcenterGroupsDictionary>>, TError, TData>
  axios?: AxiosRequestConfig
}): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {
  const { query: queryOptions, axios: axiosOptions } = options ?? {}

  const queryKey = queryOptions?.queryKey ?? getGetWorkcenterGroupsDictionaryQueryKey()

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getWorkcenterGroupsDictionary>>> = ({
    signal
  }) => getWorkcenterGroupsDictionary({ signal, ...axiosOptions })

  const query = useQuery<Awaited<ReturnType<typeof getWorkcenterGroupsDictionary>>, TError, TData>(
    queryKey,
    queryFn,
    queryOptions
  ) as UseQueryResult<TData, TError> & { queryKey: QueryKey }

  query.queryKey = queryKey

  return query
}

/**
 * @summary Get workcenters dictionary
 */
export const getWorkcentersDictionary = (
  options?: AxiosRequestConfig
): Promise<AxiosResponse<void>> => {
  return axios.get(`/dictionary/workcenters`, options)
}

export const getGetWorkcentersDictionaryQueryKey = () => [`/dictionary/workcenters`]

export type GetWorkcentersDictionaryQueryResult = NonNullable<
  Awaited<ReturnType<typeof getWorkcentersDictionary>>
>
export type GetWorkcentersDictionaryQueryError = AxiosError<unknown>

export const useGetWorkcentersDictionary = <
  TData = Awaited<ReturnType<typeof getWorkcentersDictionary>>,
  TError = AxiosError<unknown>
>(options?: {
  query?: UseQueryOptions<Awaited<ReturnType<typeof getWorkcentersDictionary>>, TError, TData>
  axios?: AxiosRequestConfig
}): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {
  const { query: queryOptions, axios: axiosOptions } = options ?? {}

  const queryKey = queryOptions?.queryKey ?? getGetWorkcentersDictionaryQueryKey()

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getWorkcentersDictionary>>> = ({
    signal
  }) => getWorkcentersDictionary({ signal, ...axiosOptions })

  const query = useQuery<Awaited<ReturnType<typeof getWorkcentersDictionary>>, TError, TData>(
    queryKey,
    queryFn,
    queryOptions
  ) as UseQueryResult<TData, TError> & { queryKey: QueryKey }

  query.queryKey = queryKey

  return query
}

/**
 * @summary Get user_roles dictionary
 */
export const getUserRolesDictionary = (
  options?: AxiosRequestConfig
): Promise<AxiosResponse<void>> => {
  return axios.get(`/dictionary/user_roles`, options)
}

export const getGetUserRolesDictionaryQueryKey = () => [`/dictionary/user_roles`]

export type GetUserRolesDictionaryQueryResult = NonNullable<
  Awaited<ReturnType<typeof getUserRolesDictionary>>
>
export type GetUserRolesDictionaryQueryError = AxiosError<unknown>

export const useGetUserRolesDictionary = <
  TData = Awaited<ReturnType<typeof getUserRolesDictionary>>,
  TError = AxiosError<unknown>
>(options?: {
  query?: UseQueryOptions<Awaited<ReturnType<typeof getUserRolesDictionary>>, TError, TData>
  axios?: AxiosRequestConfig
}): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {
  const { query: queryOptions, axios: axiosOptions } = options ?? {}

  const queryKey = queryOptions?.queryKey ?? getGetUserRolesDictionaryQueryKey()

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getUserRolesDictionary>>> = ({ signal }) =>
    getUserRolesDictionary({ signal, ...axiosOptions })

  const query = useQuery<Awaited<ReturnType<typeof getUserRolesDictionary>>, TError, TData>(
    queryKey,
    queryFn,
    queryOptions
  ) as UseQueryResult<TData, TError> & { queryKey: QueryKey }

  query.queryKey = queryKey

  return query
}

/**
 * @summary Get user_positions dictionary
 */
export const getUserPositionsDictionary = (
  options?: AxiosRequestConfig
): Promise<AxiosResponse<void>> => {
  return axios.get(`/dictionary/user_positions`, options)
}

export const getGetUserPositionsDictionaryQueryKey = () => [`/dictionary/user_positions`]

export type GetUserPositionsDictionaryQueryResult = NonNullable<
  Awaited<ReturnType<typeof getUserPositionsDictionary>>
>
export type GetUserPositionsDictionaryQueryError = AxiosError<unknown>

export const useGetUserPositionsDictionary = <
  TData = Awaited<ReturnType<typeof getUserPositionsDictionary>>,
  TError = AxiosError<unknown>
>(options?: {
  query?: UseQueryOptions<Awaited<ReturnType<typeof getUserPositionsDictionary>>, TError, TData>
  axios?: AxiosRequestConfig
}): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {
  const { query: queryOptions, axios: axiosOptions } = options ?? {}

  const queryKey = queryOptions?.queryKey ?? getGetUserPositionsDictionaryQueryKey()

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getUserPositionsDictionary>>> = ({
    signal
  }) => getUserPositionsDictionary({ signal, ...axiosOptions })

  const query = useQuery<Awaited<ReturnType<typeof getUserPositionsDictionary>>, TError, TData>(
    queryKey,
    queryFn,
    queryOptions
  ) as UseQueryResult<TData, TError> & { queryKey: QueryKey }

  query.queryKey = queryKey

  return query
}

/**
 * @summary Accidents Stat
 */
export const accidentsStat = (
  params: AccidentsStatParams,
  options?: AxiosRequestConfig
): Promise<AxiosResponse<void>> => {
  return axios.get(`/stat/accident`, {
    ...options,
    params: { ...params, ...options?.params }
  })
}

export const getAccidentsStatQueryKey = (params: AccidentsStatParams) => [
  `/stat/accident`,
  ...(params ? [params] : [])
]

export type AccidentsStatQueryResult = NonNullable<Awaited<ReturnType<typeof accidentsStat>>>
export type AccidentsStatQueryError = AxiosError<unknown>

export const useAccidentsStat = <
  TData = Awaited<ReturnType<typeof accidentsStat>>,
  TError = AxiosError<unknown>
>(
  params: AccidentsStatParams,
  options?: {
    query?: UseQueryOptions<Awaited<ReturnType<typeof accidentsStat>>, TError, TData>
    axios?: AxiosRequestConfig
  }
): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {
  const { query: queryOptions, axios: axiosOptions } = options ?? {}

  const queryKey = queryOptions?.queryKey ?? getAccidentsStatQueryKey(params)

  const queryFn: QueryFunction<Awaited<ReturnType<typeof accidentsStat>>> = ({ signal }) =>
    accidentsStat(params, { signal, ...axiosOptions })

  const query = useQuery<Awaited<ReturnType<typeof accidentsStat>>, TError, TData>(
    queryKey,
    queryFn,
    queryOptions
  ) as UseQueryResult<TData, TError> & { queryKey: QueryKey }

  query.queryKey = queryKey

  return query
}

/**
 * @summary Audit Findings Closure Stat
 */
export const auditFindingsClosureStat = (
  params: AuditFindingsClosureStatParams,
  options?: AxiosRequestConfig
): Promise<AxiosResponse<void>> => {
  return axios.get(`/stat/afc`, {
    ...options,
    params: { ...params, ...options?.params }
  })
}

export const getAuditFindingsClosureStatQueryKey = (params: AuditFindingsClosureStatParams) => [
  `/stat/afc`,
  ...(params ? [params] : [])
]

export type AuditFindingsClosureStatQueryResult = NonNullable<
  Awaited<ReturnType<typeof auditFindingsClosureStat>>
>
export type AuditFindingsClosureStatQueryError = AxiosError<unknown>

export const useAuditFindingsClosureStat = <
  TData = Awaited<ReturnType<typeof auditFindingsClosureStat>>,
  TError = AxiosError<unknown>
>(
  params: AuditFindingsClosureStatParams,
  options?: {
    query?: UseQueryOptions<Awaited<ReturnType<typeof auditFindingsClosureStat>>, TError, TData>
    axios?: AxiosRequestConfig
  }
): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {
  const { query: queryOptions, axios: axiosOptions } = options ?? {}

  const queryKey = queryOptions?.queryKey ?? getAuditFindingsClosureStatQueryKey(params)

  const queryFn: QueryFunction<Awaited<ReturnType<typeof auditFindingsClosureStat>>> = ({
    signal
  }) => auditFindingsClosureStat(params, { signal, ...axiosOptions })

  const query = useQuery<Awaited<ReturnType<typeof auditFindingsClosureStat>>, TError, TData>(
    queryKey,
    queryFn,
    queryOptions
  ) as UseQueryResult<TData, TError> & { queryKey: QueryKey }

  query.queryKey = queryKey

  return query
}

/**
 * @summary Corrective Action Implementation Stat
 */
export const correctiveActionImplementationStat = (
  params: CorrectiveActionImplementationStatParams,
  options?: AxiosRequestConfig
): Promise<AxiosResponse<void>> => {
  return axios.get(`/stat/cai`, {
    ...options,
    params: { ...params, ...options?.params }
  })
}

export const getCorrectiveActionImplementationStatQueryKey = (
  params: CorrectiveActionImplementationStatParams
) => [`/stat/cai`, ...(params ? [params] : [])]

export type CorrectiveActionImplementationStatQueryResult = NonNullable<
  Awaited<ReturnType<typeof correctiveActionImplementationStat>>
>
export type CorrectiveActionImplementationStatQueryError = AxiosError<unknown>

export const useCorrectiveActionImplementationStat = <
  TData = Awaited<ReturnType<typeof correctiveActionImplementationStat>>,
  TError = AxiosError<unknown>
>(
  params: CorrectiveActionImplementationStatParams,
  options?: {
    query?: UseQueryOptions<
      Awaited<ReturnType<typeof correctiveActionImplementationStat>>,
      TError,
      TData
    >
    axios?: AxiosRequestConfig
  }
): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {
  const { query: queryOptions, axios: axiosOptions } = options ?? {}

  const queryKey = queryOptions?.queryKey ?? getCorrectiveActionImplementationStatQueryKey(params)

  const queryFn: QueryFunction<Awaited<ReturnType<typeof correctiveActionImplementationStat>>> = ({
    signal
  }) => correctiveActionImplementationStat(params, { signal, ...axiosOptions })

  const query = useQuery<
    Awaited<ReturnType<typeof correctiveActionImplementationStat>>,
    TError,
    TData
  >(queryKey, queryFn, queryOptions) as UseQueryResult<TData, TError> & { queryKey: QueryKey }

  query.queryKey = queryKey

  return query
}

/**
 * @summary Workcenters Ticket Statuses Statictics
 */
export const workcentersStat = (
  factoryId: number,
  params?: WorkcentersStatParams,
  options?: AxiosRequestConfig
): Promise<AxiosResponse<void>> => {
  return axios.get(`/stat/workcenters/${factoryId}`, {
    ...options,
    params: { ...params, ...options?.params }
  })
}

export const getWorkcentersStatQueryKey = (factoryId: number, params?: WorkcentersStatParams) => [
  `/stat/workcenters/${factoryId}`,
  ...(params ? [params] : [])
]

export type WorkcentersStatQueryResult = NonNullable<Awaited<ReturnType<typeof workcentersStat>>>
export type WorkcentersStatQueryError = AxiosError<unknown>

export const useWorkcentersStat = <
  TData = Awaited<ReturnType<typeof workcentersStat>>,
  TError = AxiosError<unknown>
>(
  factoryId: number,
  params?: WorkcentersStatParams,
  options?: {
    query?: UseQueryOptions<Awaited<ReturnType<typeof workcentersStat>>, TError, TData>
    axios?: AxiosRequestConfig
  }
): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {
  const { query: queryOptions, axios: axiosOptions } = options ?? {}

  const queryKey = queryOptions?.queryKey ?? getWorkcentersStatQueryKey(factoryId, params)

  const queryFn: QueryFunction<Awaited<ReturnType<typeof workcentersStat>>> = ({ signal }) =>
    workcentersStat(factoryId, params, { signal, ...axiosOptions })

  const query = useQuery<Awaited<ReturnType<typeof workcentersStat>>, TError, TData>(
    queryKey,
    queryFn,
    { enabled: !!factoryId, ...queryOptions }
  ) as UseQueryResult<TData, TError> & { queryKey: QueryKey }

  query.queryKey = queryKey

  return query
}

/**
 * Display a listing of the resource.

//  * @param Request $request
//  * @return LengthAwarePaginator
 * @summary Get Paginated Ticket List
 */
export const getPaginatedTicketList = (
  params?: GetPaginatedTicketListParams,
  options?: AxiosRequestConfig
): Promise<AxiosResponse<void>> => {
  return axios.get(`/tickets/list/filtered`, {
    ...options,
    params: { ...params, ...options?.params }
  })
}

export const getGetPaginatedTicketListQueryKey = (params?: GetPaginatedTicketListParams) => [
  `/tickets/list/filtered`,
  ...(params ? [params] : [])
]

export type GetPaginatedTicketListQueryResult = NonNullable<
  Awaited<ReturnType<typeof getPaginatedTicketList>>
>
export type GetPaginatedTicketListQueryError = AxiosError<unknown>

export const useGetPaginatedTicketList = <
  TData = Awaited<ReturnType<typeof getPaginatedTicketList>>,
  TError = AxiosError<unknown>
>(
  params?: GetPaginatedTicketListParams,
  options?: {
    query?: UseQueryOptions<Awaited<ReturnType<typeof getPaginatedTicketList>>, TError, TData>
    axios?: AxiosRequestConfig
  }
): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {
  const { query: queryOptions, axios: axiosOptions } = options ?? {}

  const queryKey = queryOptions?.queryKey ?? getGetPaginatedTicketListQueryKey(params)

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getPaginatedTicketList>>> = ({ signal }) =>
    getPaginatedTicketList(params, { signal, ...axiosOptions })

  const query = useQuery<Awaited<ReturnType<typeof getPaginatedTicketList>>, TError, TData>(
    queryKey,
    queryFn,
    queryOptions
  ) as UseQueryResult<TData, TError> & { queryKey: QueryKey }

  query.queryKey = queryKey

  return query
}

/**
 * Store a newly created resource in storage.
 * @summary Create New Ticket
 */
export const createNewTicket = (
  ticket: Ticket,
  options?: AxiosRequestConfig
): Promise<AxiosResponse<void>> => {
  return axios.post(`/tickets`, ticket, options)
}

export type CreateNewTicketMutationResult = NonNullable<Awaited<ReturnType<typeof createNewTicket>>>
export type CreateNewTicketMutationBody = Ticket
export type CreateNewTicketMutationError = AxiosError<unknown>

export const useCreateNewTicket = <TError = AxiosError<unknown>, TContext = unknown>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof createNewTicket>>,
    TError,
    { data: Ticket },
    TContext
  >
  axios?: AxiosRequestConfig
}) => {
  const { mutation: mutationOptions, axios: axiosOptions } = options ?? {}

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof createNewTicket>>,
    { data: Ticket }
  > = (props) => {
    const { data } = props ?? {}

    return createNewTicket(data, axiosOptions)
  }

  return useMutation<
    Awaited<ReturnType<typeof createNewTicket>>,
    TError,
    { data: Ticket },
    TContext
  >(mutationFn, mutationOptions)
}

/**
 * Display the specified resource.
 * @summary Read Ticket By ID
 */
export const readTicketByID = (
  ticketId: number,
  options?: AxiosRequestConfig
): Promise<AxiosResponse<Ticket>> => {
  return axios.get(`/tickets/${ticketId}`, options)
}

export const getReadTicketByIDQueryKey = (ticketId: number) => [`/tickets/${ticketId}`]

export type ReadTicketByIDQueryResult = NonNullable<Awaited<ReturnType<typeof readTicketByID>>>
export type ReadTicketByIDQueryError = AxiosError<unknown>

export const useReadTicketByID = <
  TData = Awaited<ReturnType<typeof readTicketByID>>,
  TError = AxiosError<unknown>
>(
  ticketId: number,
  options?: {
    query?: UseQueryOptions<Awaited<ReturnType<typeof readTicketByID>>, TError, TData>
    axios?: AxiosRequestConfig
  }
): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {
  const { query: queryOptions, axios: axiosOptions } = options ?? {}

  const queryKey = queryOptions?.queryKey ?? getReadTicketByIDQueryKey(ticketId)

  const queryFn: QueryFunction<Awaited<ReturnType<typeof readTicketByID>>> = ({ signal }) =>
    readTicketByID(ticketId, { signal, ...axiosOptions })

  const query = useQuery<Awaited<ReturnType<typeof readTicketByID>>, TError, TData>(
    queryKey,
    queryFn,
    { enabled: !!ticketId, ...queryOptions }
  ) as UseQueryResult<TData, TError> & { queryKey: QueryKey }

  query.queryKey = queryKey

  return query
}

/**
 * Update the specified resource in storage.
 * @summary Update Ticket By ID
 */
export const updateTicketByID = (
  ticketId: number,
  ticket: Ticket,
  options?: AxiosRequestConfig
): Promise<AxiosResponse<Ticket>> => {
  return axios.put(`/tickets/${ticketId}`, ticket, options)
}

export type UpdateTicketByIDMutationResult = NonNullable<
  Awaited<ReturnType<typeof updateTicketByID>>
>
export type UpdateTicketByIDMutationBody = Ticket
export type UpdateTicketByIDMutationError = AxiosError<unknown>

export const useUpdateTicketByID = <TError = AxiosError<unknown>, TContext = unknown>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof updateTicketByID>>,
    TError,
    { ticketId: number; data: Ticket },
    TContext
  >
  axios?: AxiosRequestConfig
}) => {
  const { mutation: mutationOptions, axios: axiosOptions } = options ?? {}

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof updateTicketByID>>,
    { ticketId: number; data: Ticket }
  > = (props) => {
    const { ticketId, data } = props ?? {}

    return updateTicketByID(ticketId, data, axiosOptions)
  }

  return useMutation<
    Awaited<ReturnType<typeof updateTicketByID>>,
    TError,
    { ticketId: number; data: Ticket },
    TContext
  >(mutationFn, mutationOptions)
}

/**
 * Remove the specified resource from storage.
 * @summary Delete Ticket By ID
 */
export const deleteTicketByID = (
  ticketId: number,
  options?: AxiosRequestConfig
): Promise<AxiosResponse<void>> => {
  return axios.delete(`/tickets/${ticketId}`, options)
}

export type DeleteTicketByIDMutationResult = NonNullable<
  Awaited<ReturnType<typeof deleteTicketByID>>
>

export type DeleteTicketByIDMutationError = AxiosError<unknown>

export const useDeleteTicketByID = <TError = AxiosError<unknown>, TContext = unknown>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof deleteTicketByID>>,
    TError,
    { ticketId: number },
    TContext
  >
  axios?: AxiosRequestConfig
}) => {
  const { mutation: mutationOptions, axios: axiosOptions } = options ?? {}

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof deleteTicketByID>>,
    { ticketId: number }
  > = (props) => {
    const { ticketId } = props ?? {}

    return deleteTicketByID(ticketId, axiosOptions)
  }

  return useMutation<
    Awaited<ReturnType<typeof deleteTicketByID>>,
    TError,
    { ticketId: number },
    TContext
  >(mutationFn, mutationOptions)
}

/**
 * Display the specified resource.
 * @summary Read corrective actions by ticket id
 */
export const readCorrectiveActionsByTicketId = (
  ticketId: number,
  options?: AxiosRequestConfig
): Promise<AxiosResponse<CorrectiveAction[]>> => {
  return axios.get(`/tickets/cas/${ticketId}`, options)
}

export const getReadCorrectiveActionsByTicketIdQueryKey = (ticketId: number) => [
  `/tickets/cas/${ticketId}`
]

export type ReadCorrectiveActionsByTicketIdQueryResult = NonNullable<
  Awaited<ReturnType<typeof readCorrectiveActionsByTicketId>>
>
export type ReadCorrectiveActionsByTicketIdQueryError = AxiosError<unknown>

export const useReadCorrectiveActionsByTicketId = <
  TData = Awaited<ReturnType<typeof readCorrectiveActionsByTicketId>>,
  TError = AxiosError<unknown>
>(
  ticketId: number,
  options?: {
    query?: UseQueryOptions<
      Awaited<ReturnType<typeof readCorrectiveActionsByTicketId>>,
      TError,
      TData
    >
    axios?: AxiosRequestConfig
  }
): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {
  const { query: queryOptions, axios: axiosOptions } = options ?? {}

  const queryKey = queryOptions?.queryKey ?? getReadCorrectiveActionsByTicketIdQueryKey(ticketId)

  const queryFn: QueryFunction<Awaited<ReturnType<typeof readCorrectiveActionsByTicketId>>> = ({
    signal
  }) => readCorrectiveActionsByTicketId(ticketId, { signal, ...axiosOptions })

  const query = useQuery<
    Awaited<ReturnType<typeof readCorrectiveActionsByTicketId>>,
    TError,
    TData
  >(queryKey, queryFn, { enabled: !!ticketId, ...queryOptions }) as UseQueryResult<
    TData,
    TError
  > & { queryKey: QueryKey }

  query.queryKey = queryKey

  return query
}

/**
 * Display a listing of the resource.

//  * @return \Illuminate\Http\Response
 * @summary Workcenters Ticket Statuses Statictics
 */
export const workcentersTicketStatusesStatictics = (
  factoryId: number,
  params?: WorkcentersTicketStatusesStaticticsParams,
  options?: AxiosRequestConfig
): Promise<AxiosResponse<void>> => {
  return axios.get(`/workcenters/stat/${factoryId}`, {
    ...options,
    params: { ...params, ...options?.params }
  })
}

export const getWorkcentersTicketStatusesStaticticsQueryKey = (
  factoryId: number,
  params?: WorkcentersTicketStatusesStaticticsParams
) => [`/workcenters/stat/${factoryId}`, ...(params ? [params] : [])]

export type WorkcentersTicketStatusesStaticticsQueryResult = NonNullable<
  Awaited<ReturnType<typeof workcentersTicketStatusesStatictics>>
>
export type WorkcentersTicketStatusesStaticticsQueryError = AxiosError<unknown>

export const useWorkcentersTicketStatusesStatictics = <
  TData = Awaited<ReturnType<typeof workcentersTicketStatusesStatictics>>,
  TError = AxiosError<unknown>
>(
  factoryId: number,
  params?: WorkcentersTicketStatusesStaticticsParams,
  options?: {
    query?: UseQueryOptions<
      Awaited<ReturnType<typeof workcentersTicketStatusesStatictics>>,
      TError,
      TData
    >
    axios?: AxiosRequestConfig
  }
): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {
  const { query: queryOptions, axios: axiosOptions } = options ?? {}

  const queryKey =
    queryOptions?.queryKey ?? getWorkcentersTicketStatusesStaticticsQueryKey(factoryId, params)

  const queryFn: QueryFunction<Awaited<ReturnType<typeof workcentersTicketStatusesStatictics>>> = ({
    signal
  }) => workcentersTicketStatusesStatictics(factoryId, params, { signal, ...axiosOptions })

  const query = useQuery<
    Awaited<ReturnType<typeof workcentersTicketStatusesStatictics>>,
    TError,
    TData
  >(queryKey, queryFn, { enabled: !!factoryId, ...queryOptions }) as UseQueryResult<
    TData,
    TError
  > & { queryKey: QueryKey }

  query.queryKey = queryKey

  return query
}

/**
 * –†–µ–≥–∏—Å—Ç—Ä–∞—Ü–∏—è –Ω–æ–≤–æ–≥–æ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è
 * @summary –†–µ–≥–∏—Å—Ç—Ä–∞—Ü–∏—è
 */
export const register = (
  registerBody: RegisterBody,
  options?: AxiosRequestConfig
): Promise<AxiosResponse<Register200>> => {
  return axios.post(`/register`, registerBody, options)
}

export type RegisterMutationResult = NonNullable<Awaited<ReturnType<typeof register>>>
export type RegisterMutationBody = RegisterBody
export type RegisterMutationError = AxiosError<Register422>

export const useRegister = <TError = AxiosError<Register422>, TContext = unknown>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof register>>,
    TError,
    { data: RegisterBody },
    TContext
  >
  axios?: AxiosRequestConfig
}) => {
  const { mutation: mutationOptions, axios: axiosOptions } = options ?? {}

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof register>>,
    { data: RegisterBody }
  > = (props) => {
    const { data } = props ?? {}

    return register(data, axiosOptions)
  }

  return useMutation<
    Awaited<ReturnType<typeof register>>,
    TError,
    { data: RegisterBody },
    TContext
  >(mutationFn, mutationOptions)
}

/**
 * –ê–≤—Ç–æ—Ä–∏–∑–∞—Ü–∏—è
 * @summary –ê–≤—Ç–æ—Ä–∏–∑–∞—Ü–∏—è
 */
export const login = (
  loginBody: LoginBody,
  options?: AxiosRequestConfig
): Promise<AxiosResponse<Login200>> => {
  return axios.post(`/login`, loginBody, options)
}

export type LoginMutationResult = NonNullable<Awaited<ReturnType<typeof login>>>
export type LoginMutationBody = LoginBody
export type LoginMutationError = AxiosError<Login422>

export const useLogin = <TError = AxiosError<Login422>, TContext = unknown>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof login>>,
    TError,
    { data: LoginBody },
    TContext
  >
  axios?: AxiosRequestConfig
}) => {
  const { mutation: mutationOptions, axios: axiosOptions } = options ?? {}

  const mutationFn: MutationFunction<Awaited<ReturnType<typeof login>>, { data: LoginBody }> = (
    props
  ) => {
    const { data } = props ?? {}

    return login(data, axiosOptions)
  }

  return useMutation<Awaited<ReturnType<typeof login>>, TError, { data: LoginBody }, TContext>(
    mutationFn,
    mutationOptions
  )
}

/**
 * –í—ã—Ö–æ–¥
 * @summary –í—ã—Ö–æ–¥
 */
export const logout = (options?: AxiosRequestConfig): Promise<AxiosResponse<Logout200>> => {
  return axios.get(`/logout`, options)
}

export const getLogoutQueryKey = () => [`/logout`]

export type LogoutQueryResult = NonNullable<Awaited<ReturnType<typeof logout>>>
export type LogoutQueryError = AxiosError<unknown>

export const useLogout = <
  TData = Awaited<ReturnType<typeof logout>>,
  TError = AxiosError<unknown>
>(options?: {
  query?: UseQueryOptions<Awaited<ReturnType<typeof logout>>, TError, TData>
  axios?: AxiosRequestConfig
}): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {
  const { query: queryOptions, axios: axiosOptions } = options ?? {}

  const queryKey = queryOptions?.queryKey ?? getLogoutQueryKey()

  const queryFn: QueryFunction<Awaited<ReturnType<typeof logout>>> = ({ signal }) =>
    logout({ signal, ...axiosOptions })

  const query = useQuery<Awaited<ReturnType<typeof logout>>, TError, TData>(
    queryKey,
    queryFn,
    queryOptions
  ) as UseQueryResult<TData, TError> & { queryKey: QueryKey }

  query.queryKey = queryKey

  return query
}

/**
 * –ü–æ–ª—É—á–µ–Ω–∏–µ —Å–ø–∏—Å–∫–∞ —Ñ–∞–±—Ä–∏–∫
 * @summary –ü–æ–ª—É—á–µ–Ω–∏–µ —Å–ø–∏—Å–∫–∞ —Ñ–∞–±—Ä–∏–∫
 */
export const readFactorie = (options?: AxiosRequestConfig): Promise<AxiosResponse<Factory>> => {
  return axios.get(`/readFactorie`, options)
}

export const getReadFactorieQueryKey = () => [`/readFactorie`]

export type ReadFactorieQueryResult = NonNullable<Awaited<ReturnType<typeof readFactorie>>>
export type ReadFactorieQueryError = AxiosError<unknown>

export const useReadFactorie = <
  TData = Awaited<ReturnType<typeof readFactorie>>,
  TError = AxiosError<unknown>
>(options?: {
  query?: UseQueryOptions<Awaited<ReturnType<typeof readFactorie>>, TError, TData>
  axios?: AxiosRequestConfig
}): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {
  const { query: queryOptions, axios: axiosOptions } = options ?? {}

  const queryKey = queryOptions?.queryKey ?? getReadFactorieQueryKey()

  const queryFn: QueryFunction<Awaited<ReturnType<typeof readFactorie>>> = ({ signal }) =>
    readFactorie({ signal, ...axiosOptions })

  const query = useQuery<Awaited<ReturnType<typeof readFactorie>>, TError, TData>(
    queryKey,
    queryFn,
    queryOptions
  ) as UseQueryResult<TData, TError> & { queryKey: QueryKey }

  query.queryKey = queryKey

  return query
}

/**
 * –ü–æ–ª—É—á–µ–Ω–∏–µ —Å–ø–∏—Å–∫–∞ –¥–æ–ª–∂–Ω–æ—Å—Ç–µ–π
 * @summary –ü–æ–ª—É—á–µ–Ω–∏–µ —Å–ø–∏—Å–∫–∞ –¥–æ–ª–∂–Ω–æ—Å—Ç–µ–π
 */
export const readUsersPositions = (
  options?: AxiosRequestConfig
): Promise<AxiosResponse<UserPosition>> => {
  return axios.get(`/readUsersPositions`, options)
}

export const getReadUsersPositionsQueryKey = () => [`/readUsersPositions`]

export type ReadUsersPositionsQueryResult = NonNullable<
  Awaited<ReturnType<typeof readUsersPositions>>
>
export type ReadUsersPositionsQueryError = AxiosError<unknown>

export const useReadUsersPositions = <
  TData = Awaited<ReturnType<typeof readUsersPositions>>,
  TError = AxiosError<unknown>
>(options?: {
  query?: UseQueryOptions<Awaited<ReturnType<typeof readUsersPositions>>, TError, TData>
  axios?: AxiosRequestConfig
}): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {
  const { query: queryOptions, axios: axiosOptions } = options ?? {}

  const queryKey = queryOptions?.queryKey ?? getReadUsersPositionsQueryKey()

  const queryFn: QueryFunction<Awaited<ReturnType<typeof readUsersPositions>>> = ({ signal }) =>
    readUsersPositions({ signal, ...axiosOptions })

  const query = useQuery<Awaited<ReturnType<typeof readUsersPositions>>, TError, TData>(
    queryKey,
    queryFn,
    queryOptions
  ) as UseQueryResult<TData, TError> & { queryKey: QueryKey }

  query.queryKey = queryKey

  return query
}

/**
 * –ü–æ–ª—É—á–µ–Ω–∏–µ —Å–ø–∏—Å–∫–∞ —Å–æ—Ç—Ä—É–¥–Ω–∏–∫–æ–≤
 * @summary –ü–æ–ª—É—á–µ–Ω–∏–µ —Å–ø–∏—Å–∫–∞ —Å–æ—Ç—Ä—É–¥–Ω–∏–∫–æ–≤
 */
export const readUsers = (options?: AxiosRequestConfig): Promise<AxiosResponse<User>> => {
  return axios.get(`/readEmployees`, options)
}

export const getReadUsersQueryKey = () => [`/readEmployees`]

export type ReadUsersQueryResult = NonNullable<Awaited<ReturnType<typeof readUsers>>>
export type ReadUsersQueryError = AxiosError<unknown>

export const useReadUsers = <
  TData = Awaited<ReturnType<typeof readUsers>>,
  TError = AxiosError<unknown>
>(options?: {
  query?: UseQueryOptions<Awaited<ReturnType<typeof readUsers>>, TError, TData>
  axios?: AxiosRequestConfig
}): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {
  const { query: queryOptions, axios: axiosOptions } = options ?? {}

  const queryKey = queryOptions?.queryKey ?? getReadUsersQueryKey()

  const queryFn: QueryFunction<Awaited<ReturnType<typeof readUsers>>> = ({ signal }) =>
    readUsers({ signal, ...axiosOptions })

  const query = useQuery<Awaited<ReturnType<typeof readUsers>>, TError, TData>(
    queryKey,
    queryFn,
    queryOptions
  ) as UseQueryResult<TData, TError> & { queryKey: QueryKey }

  query.queryKey = queryKey

  return query
}

/**
 * –ü–æ–ª—É—á–µ–Ω–∏–µ —Å–ø–∏—Å–∫–∞ —Ä–∞–±–æ—á–∏—Ö –º–µ—Å—Ç
 * @summary –ü–æ–ª—É—á–µ–Ω–∏–µ —Å–ø–∏—Å–∫–∞ —Ä–∞–±–æ—á–∏—Ö –º–µ—Å—Ç
 */
export const readWorkCenters = (
  options?: AxiosRequestConfig
): Promise<AxiosResponse<Workcenter>> => {
  return axios.get(`/readWorkCenters`, options)
}

export const getReadWorkCentersQueryKey = () => [`/readWorkCenters`]

export type ReadWorkCentersQueryResult = NonNullable<Awaited<ReturnType<typeof readWorkCenters>>>
export type ReadWorkCentersQueryError = AxiosError<unknown>

export const useReadWorkCenters = <
  TData = Awaited<ReturnType<typeof readWorkCenters>>,
  TError = AxiosError<unknown>
>(options?: {
  query?: UseQueryOptions<Awaited<ReturnType<typeof readWorkCenters>>, TError, TData>
  axios?: AxiosRequestConfig
}): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {
  const { query: queryOptions, axios: axiosOptions } = options ?? {}

  const queryKey = queryOptions?.queryKey ?? getReadWorkCentersQueryKey()

  const queryFn: QueryFunction<Awaited<ReturnType<typeof readWorkCenters>>> = ({ signal }) =>
    readWorkCenters({ signal, ...axiosOptions })

  const query = useQuery<Awaited<ReturnType<typeof readWorkCenters>>, TError, TData>(
    queryKey,
    queryFn,
    queryOptions
  ) as UseQueryResult<TData, TError> & { queryKey: QueryKey }

  query.queryKey = queryKey

  return query
}
