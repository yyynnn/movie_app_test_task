/**
 * Generated by orval v6.10.2 üç∫
 * Do not edit manually.
 * OpenApi Documentation
 * –î–æ–∫—É–º–µ–Ω—Ç–∞—Ü–∏—è –¥–ª—è –º–∏–∫—Ä–æ —Å–µ—Ä–≤–∏—Å–∞
 * OpenAPI spec version: 1.0.0
 */
import type { MutationFunction, QueryFunction, QueryKey, UseMutationOptions, UseQueryOptions, UseQueryResult } from '@tanstack/react-query'
import { useMutation, useQuery } from '@tanstack/react-query'
import type { AxiosError, AxiosRequestConfig, AxiosResponse } from 'axios'
import axios from 'axios'

import type { Ticket, User, Workcenter } from './models'

/**
 * –ü–æ–ª—É—á–µ–Ω–∏–µ –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏–∏ –æ –Ω–∞—Å—Ç—Ä–æ–π–∫–∞—Ö php –Ω–∞ —Å–µ—Ä–≤–µ—Ä–µ
 * @summary –ü–æ–ª—É—á–µ–Ω–∏–µ –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏–∏ –æ –Ω–∞—Å—Ç—Ä–æ–π–∫–∞—Ö php –Ω–∞ —Å–µ—Ä–≤–µ—Ä–µ
 */
export const php = (options?: AxiosRequestConfig): Promise<AxiosResponse<void>> => {
  return axios.get(`/php`, options)
}

export const getPhpQueryKey = () => [`/php`]

export type PhpQueryResult = NonNullable<Awaited<ReturnType<typeof php>>>
export type PhpQueryError = AxiosError<unknown>

export const usePhp = <TData = Awaited<ReturnType<typeof php>>, TError = AxiosError<unknown>>(options?: {
  query?: UseQueryOptions<Awaited<ReturnType<typeof php>>, TError, TData>
  axios?: AxiosRequestConfig
}): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {
  const { query: queryOptions, axios: axiosOptions } = options ?? {}

  const queryKey = queryOptions?.queryKey ?? getPhpQueryKey()

  const queryFn: QueryFunction<Awaited<ReturnType<typeof php>>> = ({ signal }) => php({ signal, ...axiosOptions })

  const query = useQuery<Awaited<ReturnType<typeof php>>, TError, TData>(queryKey, queryFn, queryOptions) as UseQueryResult<TData, TError> & { queryKey: QueryKey }

  query.queryKey = queryKey

  return query
}

/**
 * –ü–æ–ª—É—á–µ–Ω–∏–µ –æ—Ç–¥–µ–ª—å–Ω–æ–≥–æ —Ç–∏–∫–µ—Ç–∞
 * @summary –ü–æ–ª—É—á–µ–Ω–∏–µ –æ—Ç–¥–µ–ª—å–Ω–æ–≥–æ —Ç–∏–∫–µ—Ç–∞
 */
export const readTicket = (ticket: number, options?: AxiosRequestConfig): Promise<AxiosResponse<Ticket>> => {
  return axios.get(`/tickets/${ticket}`, options)
}

export const getReadTicketQueryKey = (ticket: number) => [`/tickets/${ticket}`]

export type ReadTicketQueryResult = NonNullable<Awaited<ReturnType<typeof readTicket>>>
export type ReadTicketQueryError = AxiosError<unknown>

export const useReadTicket = <TData = Awaited<ReturnType<typeof readTicket>>, TError = AxiosError<unknown>>(
  ticket: number,
  options?: { query?: UseQueryOptions<Awaited<ReturnType<typeof readTicket>>, TError, TData>; axios?: AxiosRequestConfig }
): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {
  const { query: queryOptions, axios: axiosOptions } = options ?? {}

  const queryKey = queryOptions?.queryKey ?? getReadTicketQueryKey(ticket)

  const queryFn: QueryFunction<Awaited<ReturnType<typeof readTicket>>> = ({ signal }) => readTicket(ticket, { signal, ...axiosOptions })

  const query = useQuery<Awaited<ReturnType<typeof readTicket>>, TError, TData>(queryKey, queryFn, { enabled: !!ticket, ...queryOptions }) as UseQueryResult<TData, TError> & { queryKey: QueryKey }

  query.queryKey = queryKey

  return query
}

/**
 * –°–æ—Ö—Ä–∞–Ω–µ–Ω–∏–µ —Ç–∏–∫–µ—Ç–∞
 * @summary –°–æ—Ö—Ä–∞–Ω–µ–Ω–∏–µ —Ç–∏–∫–µ—Ç–∞
 */
export const createTicket = (options?: AxiosRequestConfig): Promise<AxiosResponse<Ticket>> => {
  return axios.post(`/tickets`, undefined, options)
}

export type CreateTicketMutationResult = NonNullable<Awaited<ReturnType<typeof createTicket>>>

export type CreateTicketMutationError = AxiosError<unknown>

export const useCreateTicket = <TError = AxiosError<unknown>, TVariables = void, TContext = unknown>(options?: {
  mutation?: UseMutationOptions<Awaited<ReturnType<typeof createTicket>>, TError, TVariables, TContext>
  axios?: AxiosRequestConfig
}) => {
  const { mutation: mutationOptions, axios: axiosOptions } = options ?? {}

  const mutationFn: MutationFunction<Awaited<ReturnType<typeof createTicket>>, TVariables> = () => {
    return createTicket(axiosOptions)
  }

  return useMutation<Awaited<ReturnType<typeof createTicket>>, TError, TVariables, TContext>(mutationFn, mutationOptions)
}

/**
 * –ü–æ–ª—É—á–µ–Ω–∏–µ —Å–ø–∏—Å–∫–∞ —Ç–∏–∫–µ—Ç–æ–≤
 * @summary –ü–æ–ª—É—á–µ–Ω–∏–µ —Å–ø–∏—Å–∫–∞ —Ç–∏–∫–µ—Ç–æ–≤
 */
export const readTicketsList = (options?: AxiosRequestConfig): Promise<AxiosResponse<Ticket>> => {
  return axios.get(`/readTicketsList`, options)
}

export const getReadTicketsListQueryKey = () => [`/readTicketsList`]

export type ReadTicketsListQueryResult = NonNullable<Awaited<ReturnType<typeof readTicketsList>>>
export type ReadTicketsListQueryError = AxiosError<unknown>

export const useReadTicketsList = <TData = Awaited<ReturnType<typeof readTicketsList>>, TError = AxiosError<unknown>>(options?: {
  query?: UseQueryOptions<Awaited<ReturnType<typeof readTicketsList>>, TError, TData>
  axios?: AxiosRequestConfig
}): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {
  const { query: queryOptions, axios: axiosOptions } = options ?? {}

  const queryKey = queryOptions?.queryKey ?? getReadTicketsListQueryKey()

  const queryFn: QueryFunction<Awaited<ReturnType<typeof readTicketsList>>> = ({ signal }) => readTicketsList({ signal, ...axiosOptions })

  const query = useQuery<Awaited<ReturnType<typeof readTicketsList>>, TError, TData>(queryKey, queryFn, queryOptions) as UseQueryResult<TData, TError> & { queryKey: QueryKey }

  query.queryKey = queryKey

  return query
}

/**
 * –ü–æ–ª—É—á–µ–Ω–∏–µ —Å–ø–∏—Å–∫–∞ —Å–æ—Ç—Ä—É–¥–Ω–∏–∫–æ–≤
 * @summary –ü–æ–ª—É—á–µ–Ω–∏–µ —Å–ø–∏—Å–∫–∞ —Å–æ—Ç—Ä—É–¥–Ω–∏–∫–æ–≤
 */
export const readUsers = (options?: AxiosRequestConfig): Promise<AxiosResponse<User>> => {
  return axios.get(`/readEmployees`, options)
}

export const getReadUsersQueryKey = () => [`/readEmployees`]

export type ReadUsersQueryResult = NonNullable<Awaited<ReturnType<typeof readUsers>>>
export type ReadUsersQueryError = AxiosError<unknown>

export const useReadUsers = <TData = Awaited<ReturnType<typeof readUsers>>, TError = AxiosError<unknown>>(options?: {
  query?: UseQueryOptions<Awaited<ReturnType<typeof readUsers>>, TError, TData>
  axios?: AxiosRequestConfig
}): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {
  const { query: queryOptions, axios: axiosOptions } = options ?? {}

  const queryKey = queryOptions?.queryKey ?? getReadUsersQueryKey()

  const queryFn: QueryFunction<Awaited<ReturnType<typeof readUsers>>> = ({ signal }) => readUsers({ signal, ...axiosOptions })

  const query = useQuery<Awaited<ReturnType<typeof readUsers>>, TError, TData>(queryKey, queryFn, queryOptions) as UseQueryResult<TData, TError> & { queryKey: QueryKey }

  query.queryKey = queryKey

  return query
}

/**
 * –ü–æ–ª—É—á–µ–Ω–∏–µ —Å–ø–∏—Å–∫–∞ —Ä–∞–±–æ—á–∏—Ö –º–µ—Å—Ç
 * @summary –ü–æ–ª—É—á–µ–Ω–∏–µ —Å–ø–∏—Å–∫–∞ —Ä–∞–±–æ—á–∏—Ö –º–µ—Å—Ç
 */
export const readWorkCenters = (options?: AxiosRequestConfig): Promise<AxiosResponse<Workcenter>> => {
  return axios.get(`/readWorkCenters`, options)
}

export const getReadWorkCentersQueryKey = () => [`/readWorkCenters`]

export type ReadWorkCentersQueryResult = NonNullable<Awaited<ReturnType<typeof readWorkCenters>>>
export type ReadWorkCentersQueryError = AxiosError<unknown>

export const useReadWorkCenters = <TData = Awaited<ReturnType<typeof readWorkCenters>>, TError = AxiosError<unknown>>(options?: {
  query?: UseQueryOptions<Awaited<ReturnType<typeof readWorkCenters>>, TError, TData>
  axios?: AxiosRequestConfig
}): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {
  const { query: queryOptions, axios: axiosOptions } = options ?? {}

  const queryKey = queryOptions?.queryKey ?? getReadWorkCentersQueryKey()

  const queryFn: QueryFunction<Awaited<ReturnType<typeof readWorkCenters>>> = ({ signal }) => readWorkCenters({ signal, ...axiosOptions })

  const query = useQuery<Awaited<ReturnType<typeof readWorkCenters>>, TError, TData>(queryKey, queryFn, queryOptions) as UseQueryResult<TData, TError> & { queryKey: QueryKey }

  query.queryKey = queryKey

  return query
}
