/**
 * Generated by orval v6.10.3 üç∫
 * Do not edit manually.
 * OpenApi Documentation
 * –î–æ–∫—É–º–µ–Ω—Ç–∞—Ü–∏—è –¥–ª—è –º–∏–∫—Ä–æ —Å–µ—Ä–≤–∏—Å–∞
 * OpenAPI spec version: 1.0.0
 */
import type { MutationFunction, QueryFunction, QueryKey, UseMutationOptions, UseQueryOptions, UseQueryResult } from '@tanstack/react-query'
import { useMutation, useQuery } from '@tanstack/react-query'
import type { AxiosError, AxiosRequestConfig, AxiosResponse } from 'axios'
import axios from 'axios'

import type { Factory, Login200, Login422, LoginBody, Logout200, Register200, Register422, RegisterBody, Ticket, User, UserPosition, Workcenter } from './models'

/**
 * –ü–æ–ª—É—á–µ–Ω–∏–µ –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏–∏ –æ –Ω–∞—Å—Ç—Ä–æ–π–∫–∞—Ö php –Ω–∞ —Å–µ—Ä–≤–µ—Ä–µ
 * @summary –ü–æ–ª—É—á–µ–Ω–∏–µ –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏–∏ –æ –Ω–∞—Å—Ç—Ä–æ–π–∫–∞—Ö php –Ω–∞ —Å–µ—Ä–≤–µ—Ä–µ
 */
export const php = (options?: AxiosRequestConfig): Promise<AxiosResponse<void>> => {
  return axios.get(`/php`, options)
}

export const getPhpQueryKey = () => [`/php`]

export type PhpQueryResult = NonNullable<Awaited<ReturnType<typeof php>>>
export type PhpQueryError = AxiosError<unknown>

export const usePhp = <TData = Awaited<ReturnType<typeof php>>, TError = AxiosError<unknown>>(options?: {
  query?: UseQueryOptions<Awaited<ReturnType<typeof php>>, TError, TData>
  axios?: AxiosRequestConfig
}): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {
  const { query: queryOptions, axios: axiosOptions } = options ?? {}

  const queryKey = queryOptions?.queryKey ?? getPhpQueryKey()

  const queryFn: QueryFunction<Awaited<ReturnType<typeof php>>> = ({ signal }) => php({ signal, ...axiosOptions })

  const query = useQuery<Awaited<ReturnType<typeof php>>, TError, TData>(queryKey, queryFn, queryOptions) as UseQueryResult<TData, TError> & { queryKey: QueryKey }

  query.queryKey = queryKey

  return query
}

/**
 * –†–µ–≥–∏—Å—Ç—Ä–∞—Ü–∏—è –Ω–æ–≤–æ–≥–æ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è
 * @summary –†–µ–≥–∏—Å—Ç—Ä–∞—Ü–∏—è
 */
export const register = (registerBody: RegisterBody, options?: AxiosRequestConfig): Promise<AxiosResponse<Register200>> => {
  return axios.post(`/register`, registerBody, options)
}

export type RegisterMutationResult = NonNullable<Awaited<ReturnType<typeof register>>>
export type RegisterMutationBody = RegisterBody
export type RegisterMutationError = AxiosError<Register422>

export const useRegister = <TError = AxiosError<Register422>, TContext = unknown>(options?: {
  mutation?: UseMutationOptions<Awaited<ReturnType<typeof register>>, TError, { data: RegisterBody }, TContext>
  axios?: AxiosRequestConfig
}) => {
  const { mutation: mutationOptions, axios: axiosOptions } = options ?? {}

  const mutationFn: MutationFunction<Awaited<ReturnType<typeof register>>, { data: RegisterBody }> = (props) => {
    const { data } = props ?? {}

    return register(data, axiosOptions)
  }

  return useMutation<Awaited<ReturnType<typeof register>>, TError, { data: RegisterBody }, TContext>(mutationFn, mutationOptions)
}

/**
 * –ê–≤—Ç–æ—Ä–∏–∑–∞—Ü–∏—è
 * @summary –ê–≤—Ç–æ—Ä–∏–∑–∞—Ü–∏—è
 */
export const login = (loginBody: LoginBody, options?: AxiosRequestConfig): Promise<AxiosResponse<Login200>> => {
  return axios.post(`/login`, loginBody, options)
}

export type LoginMutationResult = NonNullable<Awaited<ReturnType<typeof login>>>
export type LoginMutationBody = LoginBody
export type LoginMutationError = AxiosError<Login422>

export const useLogin = <TError = AxiosError<Login422>, TContext = unknown>(options?: {
  mutation?: UseMutationOptions<Awaited<ReturnType<typeof login>>, TError, { data: LoginBody }, TContext>
  axios?: AxiosRequestConfig
}) => {
  const { mutation: mutationOptions, axios: axiosOptions } = options ?? {}

  const mutationFn: MutationFunction<Awaited<ReturnType<typeof login>>, { data: LoginBody }> = (props) => {
    const { data } = props ?? {}

    return login(data, axiosOptions)
  }

  return useMutation<Awaited<ReturnType<typeof login>>, TError, { data: LoginBody }, TContext>(mutationFn, mutationOptions)
}

/**
 * –í—ã—Ö–æ–¥
 * @summary –í—ã—Ö–æ–¥
 */
export const logout = (options?: AxiosRequestConfig): Promise<AxiosResponse<Logout200>> => {
  return axios.get(`/logout`, options)
}

export const getLogoutQueryKey = () => [`/logout`]

export type LogoutQueryResult = NonNullable<Awaited<ReturnType<typeof logout>>>
export type LogoutQueryError = AxiosError<unknown>

export const useLogout = <TData = Awaited<ReturnType<typeof logout>>, TError = AxiosError<unknown>>(options?: {
  query?: UseQueryOptions<Awaited<ReturnType<typeof logout>>, TError, TData>
  axios?: AxiosRequestConfig
}): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {
  const { query: queryOptions, axios: axiosOptions } = options ?? {}

  const queryKey = queryOptions?.queryKey ?? getLogoutQueryKey()

  const queryFn: QueryFunction<Awaited<ReturnType<typeof logout>>> = ({ signal }) => logout({ signal, ...axiosOptions })

  const query = useQuery<Awaited<ReturnType<typeof logout>>, TError, TData>(queryKey, queryFn, queryOptions) as UseQueryResult<TData, TError> & { queryKey: QueryKey }

  query.queryKey = queryKey

  return query
}

/**
 * –ü–æ–ª—É—á–µ–Ω–∏–µ —Å–ø–∏—Å–∫–∞ —Ñ–∞–±—Ä–∏–∫
 * @summary –ü–æ–ª—É—á–µ–Ω–∏–µ —Å–ø–∏—Å–∫–∞ —Ñ–∞–±—Ä–∏–∫
 */
export const readFactorie = (options?: AxiosRequestConfig): Promise<AxiosResponse<Factory>> => {
  return axios.get(`/readFactorie`, options)
}

export const getReadFactorieQueryKey = () => [`/readFactorie`]

export type ReadFactorieQueryResult = NonNullable<Awaited<ReturnType<typeof readFactorie>>>
export type ReadFactorieQueryError = AxiosError<unknown>

export const useReadFactorie = <TData = Awaited<ReturnType<typeof readFactorie>>, TError = AxiosError<unknown>>(options?: {
  query?: UseQueryOptions<Awaited<ReturnType<typeof readFactorie>>, TError, TData>
  axios?: AxiosRequestConfig
}): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {
  const { query: queryOptions, axios: axiosOptions } = options ?? {}

  const queryKey = queryOptions?.queryKey ?? getReadFactorieQueryKey()

  const queryFn: QueryFunction<Awaited<ReturnType<typeof readFactorie>>> = ({ signal }) => readFactorie({ signal, ...axiosOptions })

  const query = useQuery<Awaited<ReturnType<typeof readFactorie>>, TError, TData>(queryKey, queryFn, queryOptions) as UseQueryResult<TData, TError> & { queryKey: QueryKey }

  query.queryKey = queryKey

  return query
}

/**
 * –ü–æ–ª—É—á–µ–Ω–∏–µ –æ—Ç–¥–µ–ª—å–Ω–æ–≥–æ —Ç–∏–∫–µ—Ç–∞
 * @summary –ü–æ–ª—É—á–µ–Ω–∏–µ –æ—Ç–¥–µ–ª—å–Ω–æ–≥–æ —Ç–∏–∫–µ—Ç–∞
 */
export const readTicket = (ticket: number, options?: AxiosRequestConfig): Promise<AxiosResponse<Ticket>> => {
  return axios.get(`/tickets/${ticket}`, options)
}

export const getReadTicketQueryKey = (ticket: number) => [`/tickets/${ticket}`]

export type ReadTicketQueryResult = NonNullable<Awaited<ReturnType<typeof readTicket>>>
export type ReadTicketQueryError = AxiosError<unknown>

export const useReadTicket = <TData = Awaited<ReturnType<typeof readTicket>>, TError = AxiosError<unknown>>(
  ticket: number,
  options?: { query?: UseQueryOptions<Awaited<ReturnType<typeof readTicket>>, TError, TData>; axios?: AxiosRequestConfig }
): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {
  const { query: queryOptions, axios: axiosOptions } = options ?? {}

  const queryKey = queryOptions?.queryKey ?? getReadTicketQueryKey(ticket)

  const queryFn: QueryFunction<Awaited<ReturnType<typeof readTicket>>> = ({ signal }) => readTicket(ticket, { signal, ...axiosOptions })

  const query = useQuery<Awaited<ReturnType<typeof readTicket>>, TError, TData>(queryKey, queryFn, { enabled: !!ticket, ...queryOptions }) as UseQueryResult<TData, TError> & { queryKey: QueryKey }

  query.queryKey = queryKey

  return query
}

/**
 * –°–æ—Ö—Ä–∞–Ω–µ–Ω–∏–µ —Ç–∏–∫–µ—Ç–∞
 * @summary –°–æ—Ö—Ä–∞–Ω–µ–Ω–∏–µ —Ç–∏–∫–µ—Ç–∞
 */
export const createTicket = (options?: AxiosRequestConfig): Promise<AxiosResponse<Ticket>> => {
  return axios.post(`/tickets`, undefined, options)
}

export type CreateTicketMutationResult = NonNullable<Awaited<ReturnType<typeof createTicket>>>

export type CreateTicketMutationError = AxiosError<unknown>

export const useCreateTicket = <TError = AxiosError<unknown>, TVariables = void, TContext = unknown>(options?: {
  mutation?: UseMutationOptions<Awaited<ReturnType<typeof createTicket>>, TError, TVariables, TContext>
  axios?: AxiosRequestConfig
}) => {
  const { mutation: mutationOptions, axios: axiosOptions } = options ?? {}

  const mutationFn: MutationFunction<Awaited<ReturnType<typeof createTicket>>, TVariables> = () => {
    return createTicket(axiosOptions)
  }

  return useMutation<Awaited<ReturnType<typeof createTicket>>, TError, TVariables, TContext>(mutationFn, mutationOptions)
}

/**
 * –ü–æ–ª—É—á–µ–Ω–∏–µ —Å–ø–∏—Å–∫–∞ —Ç–∏–∫–µ—Ç–æ–≤
 * @summary –ü–æ–ª—É—á–µ–Ω–∏–µ —Å–ø–∏—Å–∫–∞ —Ç–∏–∫–µ—Ç–æ–≤
 */
export const readTicketsList = (options?: AxiosRequestConfig): Promise<AxiosResponse<Ticket>> => {
  return axios.get(`/readTicketsList`, options)
}

export const getReadTicketsListQueryKey = () => [`/readTicketsList`]

export type ReadTicketsListQueryResult = NonNullable<Awaited<ReturnType<typeof readTicketsList>>>
export type ReadTicketsListQueryError = AxiosError<unknown>

export const useReadTicketsList = <TData = Awaited<ReturnType<typeof readTicketsList>>, TError = AxiosError<unknown>>(options?: {
  query?: UseQueryOptions<Awaited<ReturnType<typeof readTicketsList>>, TError, TData>
  axios?: AxiosRequestConfig
}): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {
  const { query: queryOptions, axios: axiosOptions } = options ?? {}

  const queryKey = queryOptions?.queryKey ?? getReadTicketsListQueryKey()

  const queryFn: QueryFunction<Awaited<ReturnType<typeof readTicketsList>>> = ({ signal }) => readTicketsList({ signal, ...axiosOptions })

  const query = useQuery<Awaited<ReturnType<typeof readTicketsList>>, TError, TData>(queryKey, queryFn, queryOptions) as UseQueryResult<TData, TError> & { queryKey: QueryKey }

  query.queryKey = queryKey

  return query
}

/**
 * –ü–æ–ª—É—á–µ–Ω–∏–µ —Å–ø–∏—Å–∫–∞ –¥–æ–ª–∂–Ω–æ—Å—Ç–µ–π
 * @summary –ü–æ–ª—É—á–µ–Ω–∏–µ —Å–ø–∏—Å–∫–∞ –¥–æ–ª–∂–Ω–æ—Å—Ç–µ–π
 */
export const readUsersPositions = (options?: AxiosRequestConfig): Promise<AxiosResponse<UserPosition>> => {
  return axios.get(`/readUsersPositions`, options)
}

export const getReadUsersPositionsQueryKey = () => [`/readUsersPositions`]

export type ReadUsersPositionsQueryResult = NonNullable<Awaited<ReturnType<typeof readUsersPositions>>>
export type ReadUsersPositionsQueryError = AxiosError<unknown>

export const useReadUsersPositions = <TData = Awaited<ReturnType<typeof readUsersPositions>>, TError = AxiosError<unknown>>(options?: {
  query?: UseQueryOptions<Awaited<ReturnType<typeof readUsersPositions>>, TError, TData>
  axios?: AxiosRequestConfig
}): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {
  const { query: queryOptions, axios: axiosOptions } = options ?? {}

  const queryKey = queryOptions?.queryKey ?? getReadUsersPositionsQueryKey()

  const queryFn: QueryFunction<Awaited<ReturnType<typeof readUsersPositions>>> = ({ signal }) => readUsersPositions({ signal, ...axiosOptions })

  const query = useQuery<Awaited<ReturnType<typeof readUsersPositions>>, TError, TData>(queryKey, queryFn, queryOptions) as UseQueryResult<TData, TError> & { queryKey: QueryKey }

  query.queryKey = queryKey

  return query
}

/**
 * –ü–æ–ª—É—á–µ–Ω–∏–µ —Å–ø–∏—Å–∫–∞ —Å–æ—Ç—Ä—É–¥–Ω–∏–∫–æ–≤
 * @summary –ü–æ–ª—É—á–µ–Ω–∏–µ —Å–ø–∏—Å–∫–∞ —Å–æ—Ç—Ä—É–¥–Ω–∏–∫–æ–≤
 */
export const readUsers = (options?: AxiosRequestConfig): Promise<AxiosResponse<User>> => {
  return axios.get(`/readEmployees`, options)
}

export const getReadUsersQueryKey = () => [`/readEmployees`]

export type ReadUsersQueryResult = NonNullable<Awaited<ReturnType<typeof readUsers>>>
export type ReadUsersQueryError = AxiosError<unknown>

export const useReadUsers = <TData = Awaited<ReturnType<typeof readUsers>>, TError = AxiosError<unknown>>(options?: {
  query?: UseQueryOptions<Awaited<ReturnType<typeof readUsers>>, TError, TData>
  axios?: AxiosRequestConfig
}): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {
  const { query: queryOptions, axios: axiosOptions } = options ?? {}

  const queryKey = queryOptions?.queryKey ?? getReadUsersQueryKey()

  const queryFn: QueryFunction<Awaited<ReturnType<typeof readUsers>>> = ({ signal }) => readUsers({ signal, ...axiosOptions })

  const query = useQuery<Awaited<ReturnType<typeof readUsers>>, TError, TData>(queryKey, queryFn, queryOptions) as UseQueryResult<TData, TError> & { queryKey: QueryKey }

  query.queryKey = queryKey

  return query
}

/**
 * –ü–æ–ª—É—á–µ–Ω–∏–µ —Å–ø–∏—Å–∫–∞ —Ä–∞–±–æ—á–∏—Ö –º–µ—Å—Ç
 * @summary –ü–æ–ª—É—á–µ–Ω–∏–µ —Å–ø–∏—Å–∫–∞ —Ä–∞–±–æ—á–∏—Ö –º–µ—Å—Ç
 */
export const readWorkCenters = (options?: AxiosRequestConfig): Promise<AxiosResponse<Workcenter>> => {
  return axios.get(`/readWorkCenters`, options)
}

export const getReadWorkCentersQueryKey = () => [`/readWorkCenters`]

export type ReadWorkCentersQueryResult = NonNullable<Awaited<ReturnType<typeof readWorkCenters>>>
export type ReadWorkCentersQueryError = AxiosError<unknown>

export const useReadWorkCenters = <TData = Awaited<ReturnType<typeof readWorkCenters>>, TError = AxiosError<unknown>>(options?: {
  query?: UseQueryOptions<Awaited<ReturnType<typeof readWorkCenters>>, TError, TData>
  axios?: AxiosRequestConfig
}): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {
  const { query: queryOptions, axios: axiosOptions } = options ?? {}

  const queryKey = queryOptions?.queryKey ?? getReadWorkCentersQueryKey()

  const queryFn: QueryFunction<Awaited<ReturnType<typeof readWorkCenters>>> = ({ signal }) => readWorkCenters({ signal, ...axiosOptions })

  const query = useQuery<Awaited<ReturnType<typeof readWorkCenters>>, TError, TData>(queryKey, queryFn, queryOptions) as UseQueryResult<TData, TError> & { queryKey: QueryKey }

  query.queryKey = queryKey

  return query
}
