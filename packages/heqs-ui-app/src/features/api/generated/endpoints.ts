/**
 * Generated by orval v6.10.3 üç∫
 * Do not edit manually.
 * OpenApi Documentation
 * –î–æ–∫—É–º–µ–Ω—Ç–∞—Ü–∏—è –¥–ª—è –º–∏–∫—Ä–æ —Å–µ—Ä–≤–∏—Å–∞
 * OpenAPI spec version: 1.0.0
 */
import type { MutationFunction, QueryFunction, QueryKey, UseMutationOptions, UseQueryOptions, UseQueryResult } from '@tanstack/react-query'
import { useMutation, useQuery } from '@tanstack/react-query'
import type { AxiosError, AxiosRequestConfig, AxiosResponse } from 'axios'
import axios from 'axios'

import type {
  CorrectiveAction,
  Factory,
  GetPaginatedCorretciveActionListParams,
  GetPaginatedTicketListParams,
  Login200,
  Login422,
  LoginBody,
  Logout200,
  Register200,
  Register422,
  RegisterBody,
  Ticket,
  User,
  UserPosition,
  Workcenter
} from './models'

/**
 * –ü–æ–ª—É—á–µ–Ω–∏–µ –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏–∏ –æ –Ω–∞—Å—Ç—Ä–æ–π–∫–∞—Ö php –Ω–∞ —Å–µ—Ä–≤–µ—Ä–µ
 * @summary –ü–æ–ª—É—á–µ–Ω–∏–µ –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏–∏ –æ –Ω–∞—Å—Ç—Ä–æ–π–∫–∞—Ö php –Ω–∞ —Å–µ—Ä–≤–µ—Ä–µ
 */
export const php = (options?: AxiosRequestConfig): Promise<AxiosResponse<void>> => {
  return axios.get(`/php`, options)
}

export const getPhpQueryKey = () => [`/php`]

export type PhpQueryResult = NonNullable<Awaited<ReturnType<typeof php>>>
export type PhpQueryError = AxiosError<unknown>

export const usePhp = <TData = Awaited<ReturnType<typeof php>>, TError = AxiosError<unknown>>(options?: {
  query?: UseQueryOptions<Awaited<ReturnType<typeof php>>, TError, TData>
  axios?: AxiosRequestConfig
}): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {
  const { query: queryOptions, axios: axiosOptions } = options ?? {}

  const queryKey = queryOptions?.queryKey ?? getPhpQueryKey()

  const queryFn: QueryFunction<Awaited<ReturnType<typeof php>>> = ({ signal }) => php({ signal, ...axiosOptions })

  const query = useQuery<Awaited<ReturnType<typeof php>>, TError, TData>(queryKey, queryFn, queryOptions) as UseQueryResult<TData, TError> & { queryKey: QueryKey }

  query.queryKey = queryKey

  return query
}

/**
 * @summary Get Paginated Corretcive Action List
 */
export const getPaginatedCorretciveActionList = (params?: GetPaginatedCorretciveActionListParams, options?: AxiosRequestConfig): Promise<AxiosResponse<void>> => {
  return axios.get(`/corretcive_actions`, {
    ...options,
    params: { ...params, ...options?.params }
  })
}

export const getGetPaginatedCorretciveActionListQueryKey = (params?: GetPaginatedCorretciveActionListParams) => [`/corretcive_actions`, ...(params ? [params] : [])]

export type GetPaginatedCorretciveActionListQueryResult = NonNullable<Awaited<ReturnType<typeof getPaginatedCorretciveActionList>>>
export type GetPaginatedCorretciveActionListQueryError = AxiosError<unknown>

export const useGetPaginatedCorretciveActionList = <TData = Awaited<ReturnType<typeof getPaginatedCorretciveActionList>>, TError = AxiosError<unknown>>(
  params?: GetPaginatedCorretciveActionListParams,
  options?: { query?: UseQueryOptions<Awaited<ReturnType<typeof getPaginatedCorretciveActionList>>, TError, TData>; axios?: AxiosRequestConfig }
): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {
  const { query: queryOptions, axios: axiosOptions } = options ?? {}

  const queryKey = queryOptions?.queryKey ?? getGetPaginatedCorretciveActionListQueryKey(params)

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getPaginatedCorretciveActionList>>> = ({ signal }) => getPaginatedCorretciveActionList(params, { signal, ...axiosOptions })

  const query = useQuery<Awaited<ReturnType<typeof getPaginatedCorretciveActionList>>, TError, TData>(queryKey, queryFn, queryOptions) as UseQueryResult<TData, TError> & { queryKey: QueryKey }

  query.queryKey = queryKey

  return query
}

/**
 * @summary Create New Corretcive Action
 */
export const createNewCorretciveAction = (correctiveAction: CorrectiveAction, options?: AxiosRequestConfig): Promise<AxiosResponse<void>> => {
  return axios.post(`/corretcive_actions`, correctiveAction, options)
}

export type CreateNewCorretciveActionMutationResult = NonNullable<Awaited<ReturnType<typeof createNewCorretciveAction>>>
export type CreateNewCorretciveActionMutationBody = CorrectiveAction
export type CreateNewCorretciveActionMutationError = AxiosError<unknown>

export const useCreateNewCorretciveAction = <TError = AxiosError<unknown>, TContext = unknown>(options?: {
  mutation?: UseMutationOptions<Awaited<ReturnType<typeof createNewCorretciveAction>>, TError, { data: CorrectiveAction }, TContext>
  axios?: AxiosRequestConfig
}) => {
  const { mutation: mutationOptions, axios: axiosOptions } = options ?? {}

  const mutationFn: MutationFunction<Awaited<ReturnType<typeof createNewCorretciveAction>>, { data: CorrectiveAction }> = (props) => {
    const { data } = props ?? {}

    return createNewCorretciveAction(data, axiosOptions)
  }

  return useMutation<Awaited<ReturnType<typeof createNewCorretciveAction>>, TError, { data: CorrectiveAction }, TContext>(mutationFn, mutationOptions)
}

/**
 * @summary Read Corretcive Action By ID
 */
export const readCorretciveActionByID = (corretciveActionId: number, options?: AxiosRequestConfig): Promise<AxiosResponse<CorrectiveAction>> => {
  return axios.get(`/corretcive_actions/${corretciveActionId}`, options)
}

export const getReadCorretciveActionByIDQueryKey = (corretciveActionId: number) => [`/corretcive_actions/${corretciveActionId}`]

export type ReadCorretciveActionByIDQueryResult = NonNullable<Awaited<ReturnType<typeof readCorretciveActionByID>>>
export type ReadCorretciveActionByIDQueryError = AxiosError<unknown>

export const useReadCorretciveActionByID = <TData = Awaited<ReturnType<typeof readCorretciveActionByID>>, TError = AxiosError<unknown>>(
  corretciveActionId: number,
  options?: { query?: UseQueryOptions<Awaited<ReturnType<typeof readCorretciveActionByID>>, TError, TData>; axios?: AxiosRequestConfig }
): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {
  const { query: queryOptions, axios: axiosOptions } = options ?? {}

  const queryKey = queryOptions?.queryKey ?? getReadCorretciveActionByIDQueryKey(corretciveActionId)

  const queryFn: QueryFunction<Awaited<ReturnType<typeof readCorretciveActionByID>>> = ({ signal }) => readCorretciveActionByID(corretciveActionId, { signal, ...axiosOptions })

  const query = useQuery<Awaited<ReturnType<typeof readCorretciveActionByID>>, TError, TData>(queryKey, queryFn, { enabled: !!corretciveActionId, ...queryOptions }) as UseQueryResult<
    TData,
    TError
  > & { queryKey: QueryKey }

  query.queryKey = queryKey

  return query
}

/**
 * @summary Update Corretcive Action By ID
 */
export const updateCorretciveActionByID = (corretciveActionId: number, correctiveAction: CorrectiveAction, options?: AxiosRequestConfig): Promise<AxiosResponse<CorrectiveAction>> => {
  return axios.put(`/corretcive_actions/${corretciveActionId}`, correctiveAction, options)
}

export type UpdateCorretciveActionByIDMutationResult = NonNullable<Awaited<ReturnType<typeof updateCorretciveActionByID>>>
export type UpdateCorretciveActionByIDMutationBody = CorrectiveAction
export type UpdateCorretciveActionByIDMutationError = AxiosError<unknown>

export const useUpdateCorretciveActionByID = <TError = AxiosError<unknown>, TContext = unknown>(options?: {
  mutation?: UseMutationOptions<Awaited<ReturnType<typeof updateCorretciveActionByID>>, TError, { corretciveActionId: number; data: CorrectiveAction }, TContext>
  axios?: AxiosRequestConfig
}) => {
  const { mutation: mutationOptions, axios: axiosOptions } = options ?? {}

  const mutationFn: MutationFunction<Awaited<ReturnType<typeof updateCorretciveActionByID>>, { corretciveActionId: number; data: CorrectiveAction }> = (props) => {
    const { corretciveActionId, data } = props ?? {}

    return updateCorretciveActionByID(corretciveActionId, data, axiosOptions)
  }

  return useMutation<Awaited<ReturnType<typeof updateCorretciveActionByID>>, TError, { corretciveActionId: number; data: CorrectiveAction }, TContext>(mutationFn, mutationOptions)
}

/**
 * @summary Delete Corretcive Action By ID
 */
export const deleteCorretciveActionByID = (corretciveActionId: number, options?: AxiosRequestConfig): Promise<AxiosResponse<void>> => {
  return axios.delete(`/corretcive_actions/${corretciveActionId}`, options)
}

export type DeleteCorretciveActionByIDMutationResult = NonNullable<Awaited<ReturnType<typeof deleteCorretciveActionByID>>>

export type DeleteCorretciveActionByIDMutationError = AxiosError<unknown>

export const useDeleteCorretciveActionByID = <TError = AxiosError<unknown>, TContext = unknown>(options?: {
  mutation?: UseMutationOptions<Awaited<ReturnType<typeof deleteCorretciveActionByID>>, TError, { corretciveActionId: number }, TContext>
  axios?: AxiosRequestConfig
}) => {
  const { mutation: mutationOptions, axios: axiosOptions } = options ?? {}

  const mutationFn: MutationFunction<Awaited<ReturnType<typeof deleteCorretciveActionByID>>, { corretciveActionId: number }> = (props) => {
    const { corretciveActionId } = props ?? {}

    return deleteCorretciveActionByID(corretciveActionId, axiosOptions)
  }

  return useMutation<Awaited<ReturnType<typeof deleteCorretciveActionByID>>, TError, { corretciveActionId: number }, TContext>(mutationFn, mutationOptions)
}

/**
 * @summary Get Paginated Ticket List
 */
export const getPaginatedTicketList = (params?: GetPaginatedTicketListParams, options?: AxiosRequestConfig): Promise<AxiosResponse<void>> => {
  return axios.get(`/tickets`, {
    ...options,
    params: { ...params, ...options?.params }
  })
}

export const getGetPaginatedTicketListQueryKey = (params?: GetPaginatedTicketListParams) => [`/tickets`, ...(params ? [params] : [])]

export type GetPaginatedTicketListQueryResult = NonNullable<Awaited<ReturnType<typeof getPaginatedTicketList>>>
export type GetPaginatedTicketListQueryError = AxiosError<unknown>

export const useGetPaginatedTicketList = <TData = Awaited<ReturnType<typeof getPaginatedTicketList>>, TError = AxiosError<unknown>>(
  params?: GetPaginatedTicketListParams,
  options?: { query?: UseQueryOptions<Awaited<ReturnType<typeof getPaginatedTicketList>>, TError, TData>; axios?: AxiosRequestConfig }
): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {
  const { query: queryOptions, axios: axiosOptions } = options ?? {}

  const queryKey = queryOptions?.queryKey ?? getGetPaginatedTicketListQueryKey(params)

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getPaginatedTicketList>>> = ({ signal }) => getPaginatedTicketList(params, { signal, ...axiosOptions })

  const query = useQuery<Awaited<ReturnType<typeof getPaginatedTicketList>>, TError, TData>(queryKey, queryFn, queryOptions) as UseQueryResult<TData, TError> & { queryKey: QueryKey }

  query.queryKey = queryKey

  return query
}

/**
 * @summary Create New Ticket
 */
export const createNewTicket = (ticket: Ticket, options?: AxiosRequestConfig): Promise<AxiosResponse<void>> => {
  return axios.post(`/tickets`, ticket, options)
}

export type CreateNewTicketMutationResult = NonNullable<Awaited<ReturnType<typeof createNewTicket>>>
export type CreateNewTicketMutationBody = Ticket
export type CreateNewTicketMutationError = AxiosError<unknown>

export const useCreateNewTicket = <TError = AxiosError<unknown>, TContext = unknown>(options?: {
  mutation?: UseMutationOptions<Awaited<ReturnType<typeof createNewTicket>>, TError, { data: Ticket }, TContext>
  axios?: AxiosRequestConfig
}) => {
  const { mutation: mutationOptions, axios: axiosOptions } = options ?? {}

  const mutationFn: MutationFunction<Awaited<ReturnType<typeof createNewTicket>>, { data: Ticket }> = (props) => {
    const { data } = props ?? {}

    return createNewTicket(data, axiosOptions)
  }

  return useMutation<Awaited<ReturnType<typeof createNewTicket>>, TError, { data: Ticket }, TContext>(mutationFn, mutationOptions)
}

/**
 * @summary Read Ticket By ID
 */
export const readTicketByID = (ticketId: number, options?: AxiosRequestConfig): Promise<AxiosResponse<Ticket>> => {
  return axios.get(`/tickets/${ticketId}`, options)
}

export const getReadTicketByIDQueryKey = (ticketId: number) => [`/tickets/${ticketId}`]

export type ReadTicketByIDQueryResult = NonNullable<Awaited<ReturnType<typeof readTicketByID>>>
export type ReadTicketByIDQueryError = AxiosError<unknown>

export const useReadTicketByID = <TData = Awaited<ReturnType<typeof readTicketByID>>, TError = AxiosError<unknown>>(
  ticketId: number,
  options?: { query?: UseQueryOptions<Awaited<ReturnType<typeof readTicketByID>>, TError, TData>; axios?: AxiosRequestConfig }
): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {
  const { query: queryOptions, axios: axiosOptions } = options ?? {}

  const queryKey = queryOptions?.queryKey ?? getReadTicketByIDQueryKey(ticketId)

  const queryFn: QueryFunction<Awaited<ReturnType<typeof readTicketByID>>> = ({ signal }) => readTicketByID(ticketId, { signal, ...axiosOptions })

  const query = useQuery<Awaited<ReturnType<typeof readTicketByID>>, TError, TData>(queryKey, queryFn, { enabled: !!ticketId, ...queryOptions }) as UseQueryResult<TData, TError> & {
    queryKey: QueryKey
  }

  query.queryKey = queryKey

  return query
}

/**
 * @summary Update Ticket By ID
 */
export const updateTicketByID = (ticketId: number, ticket: Ticket, options?: AxiosRequestConfig): Promise<AxiosResponse<Ticket>> => {
  return axios.put(`/tickets/${ticketId}`, ticket, options)
}

export type UpdateTicketByIDMutationResult = NonNullable<Awaited<ReturnType<typeof updateTicketByID>>>
export type UpdateTicketByIDMutationBody = Ticket
export type UpdateTicketByIDMutationError = AxiosError<unknown>

export const useUpdateTicketByID = <TError = AxiosError<unknown>, TContext = unknown>(options?: {
  mutation?: UseMutationOptions<Awaited<ReturnType<typeof updateTicketByID>>, TError, { ticketId: number; data: Ticket }, TContext>
  axios?: AxiosRequestConfig
}) => {
  const { mutation: mutationOptions, axios: axiosOptions } = options ?? {}

  const mutationFn: MutationFunction<Awaited<ReturnType<typeof updateTicketByID>>, { ticketId: number; data: Ticket }> = (props) => {
    const { ticketId, data } = props ?? {}

    return updateTicketByID(ticketId, data, axiosOptions)
  }

  return useMutation<Awaited<ReturnType<typeof updateTicketByID>>, TError, { ticketId: number; data: Ticket }, TContext>(mutationFn, mutationOptions)
}

/**
 * @summary Delete Ticket By ID
 */
export const deleteTicketByID = (ticketId: number, options?: AxiosRequestConfig): Promise<AxiosResponse<void>> => {
  return axios.delete(`/tickets/${ticketId}`, options)
}

export type DeleteTicketByIDMutationResult = NonNullable<Awaited<ReturnType<typeof deleteTicketByID>>>

export type DeleteTicketByIDMutationError = AxiosError<unknown>

export const useDeleteTicketByID = <TError = AxiosError<unknown>, TContext = unknown>(options?: {
  mutation?: UseMutationOptions<Awaited<ReturnType<typeof deleteTicketByID>>, TError, { ticketId: number }, TContext>
  axios?: AxiosRequestConfig
}) => {
  const { mutation: mutationOptions, axios: axiosOptions } = options ?? {}

  const mutationFn: MutationFunction<Awaited<ReturnType<typeof deleteTicketByID>>, { ticketId: number }> = (props) => {
    const { ticketId } = props ?? {}

    return deleteTicketByID(ticketId, axiosOptions)
  }

  return useMutation<Awaited<ReturnType<typeof deleteTicketByID>>, TError, { ticketId: number }, TContext>(mutationFn, mutationOptions)
}

/**
 * –†–µ–≥–∏—Å—Ç—Ä–∞—Ü–∏—è –Ω–æ–≤–æ–≥–æ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è
 * @summary –†–µ–≥–∏—Å—Ç—Ä–∞—Ü–∏—è
 */
export const register = (registerBody: RegisterBody, options?: AxiosRequestConfig): Promise<AxiosResponse<Register200>> => {
  return axios.post(`/register`, registerBody, options)
}

export type RegisterMutationResult = NonNullable<Awaited<ReturnType<typeof register>>>
export type RegisterMutationBody = RegisterBody
export type RegisterMutationError = AxiosError<Register422>

export const useRegister = <TError = AxiosError<Register422>, TContext = unknown>(options?: {
  mutation?: UseMutationOptions<Awaited<ReturnType<typeof register>>, TError, { data: RegisterBody }, TContext>
  axios?: AxiosRequestConfig
}) => {
  const { mutation: mutationOptions, axios: axiosOptions } = options ?? {}

  const mutationFn: MutationFunction<Awaited<ReturnType<typeof register>>, { data: RegisterBody }> = (props) => {
    const { data } = props ?? {}

    return register(data, axiosOptions)
  }

  return useMutation<Awaited<ReturnType<typeof register>>, TError, { data: RegisterBody }, TContext>(mutationFn, mutationOptions)
}

/**
 * –ê–≤—Ç–æ—Ä–∏–∑–∞—Ü–∏—è
 * @summary –ê–≤—Ç–æ—Ä–∏–∑–∞—Ü–∏—è
 */
export const login = (loginBody: LoginBody, options?: AxiosRequestConfig): Promise<AxiosResponse<Login200>> => {
  return axios.post(`/login`, loginBody, options)
}

export type LoginMutationResult = NonNullable<Awaited<ReturnType<typeof login>>>
export type LoginMutationBody = LoginBody
export type LoginMutationError = AxiosError<Login422>

export const useLogin = <TError = AxiosError<Login422>, TContext = unknown>(options?: {
  mutation?: UseMutationOptions<Awaited<ReturnType<typeof login>>, TError, { data: LoginBody }, TContext>
  axios?: AxiosRequestConfig
}) => {
  const { mutation: mutationOptions, axios: axiosOptions } = options ?? {}

  const mutationFn: MutationFunction<Awaited<ReturnType<typeof login>>, { data: LoginBody }> = (props) => {
    const { data } = props ?? {}

    return login(data, axiosOptions)
  }

  return useMutation<Awaited<ReturnType<typeof login>>, TError, { data: LoginBody }, TContext>(mutationFn, mutationOptions)
}

/**
 * –í—ã—Ö–æ–¥
 * @summary –í—ã—Ö–æ–¥
 */
export const logout = (options?: AxiosRequestConfig): Promise<AxiosResponse<Logout200>> => {
  return axios.get(`/logout`, options)
}

export const getLogoutQueryKey = () => [`/logout`]

export type LogoutQueryResult = NonNullable<Awaited<ReturnType<typeof logout>>>
export type LogoutQueryError = AxiosError<unknown>

export const useLogout = <TData = Awaited<ReturnType<typeof logout>>, TError = AxiosError<unknown>>(options?: {
  query?: UseQueryOptions<Awaited<ReturnType<typeof logout>>, TError, TData>
  axios?: AxiosRequestConfig
}): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {
  const { query: queryOptions, axios: axiosOptions } = options ?? {}

  const queryKey = queryOptions?.queryKey ?? getLogoutQueryKey()

  const queryFn: QueryFunction<Awaited<ReturnType<typeof logout>>> = ({ signal }) => logout({ signal, ...axiosOptions })

  const query = useQuery<Awaited<ReturnType<typeof logout>>, TError, TData>(queryKey, queryFn, queryOptions) as UseQueryResult<TData, TError> & { queryKey: QueryKey }

  query.queryKey = queryKey

  return query
}

/**
 * –ü–æ–ª—É—á–µ–Ω–∏–µ —Å–ø–∏—Å–∫–∞ —Ñ–∞–±—Ä–∏–∫
 * @summary –ü–æ–ª—É—á–µ–Ω–∏–µ —Å–ø–∏—Å–∫–∞ —Ñ–∞–±—Ä–∏–∫
 */
export const readFactorie = (options?: AxiosRequestConfig): Promise<AxiosResponse<Factory>> => {
  return axios.get(`/readFactorie`, options)
}

export const getReadFactorieQueryKey = () => [`/readFactorie`]

export type ReadFactorieQueryResult = NonNullable<Awaited<ReturnType<typeof readFactorie>>>
export type ReadFactorieQueryError = AxiosError<unknown>

export const useReadFactorie = <TData = Awaited<ReturnType<typeof readFactorie>>, TError = AxiosError<unknown>>(options?: {
  query?: UseQueryOptions<Awaited<ReturnType<typeof readFactorie>>, TError, TData>
  axios?: AxiosRequestConfig
}): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {
  const { query: queryOptions, axios: axiosOptions } = options ?? {}

  const queryKey = queryOptions?.queryKey ?? getReadFactorieQueryKey()

  const queryFn: QueryFunction<Awaited<ReturnType<typeof readFactorie>>> = ({ signal }) => readFactorie({ signal, ...axiosOptions })

  const query = useQuery<Awaited<ReturnType<typeof readFactorie>>, TError, TData>(queryKey, queryFn, queryOptions) as UseQueryResult<TData, TError> & { queryKey: QueryKey }

  query.queryKey = queryKey

  return query
}

/**
 * –ü–æ–ª—É—á–µ–Ω–∏–µ —Å–ø–∏—Å–∫–∞ –¥–æ–ª–∂–Ω–æ—Å—Ç–µ–π
 * @summary –ü–æ–ª—É—á–µ–Ω–∏–µ —Å–ø–∏—Å–∫–∞ –¥–æ–ª–∂–Ω–æ—Å—Ç–µ–π
 */
export const readUsersPositions = (options?: AxiosRequestConfig): Promise<AxiosResponse<UserPosition>> => {
  return axios.get(`/readUsersPositions`, options)
}

export const getReadUsersPositionsQueryKey = () => [`/readUsersPositions`]

export type ReadUsersPositionsQueryResult = NonNullable<Awaited<ReturnType<typeof readUsersPositions>>>
export type ReadUsersPositionsQueryError = AxiosError<unknown>

export const useReadUsersPositions = <TData = Awaited<ReturnType<typeof readUsersPositions>>, TError = AxiosError<unknown>>(options?: {
  query?: UseQueryOptions<Awaited<ReturnType<typeof readUsersPositions>>, TError, TData>
  axios?: AxiosRequestConfig
}): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {
  const { query: queryOptions, axios: axiosOptions } = options ?? {}

  const queryKey = queryOptions?.queryKey ?? getReadUsersPositionsQueryKey()

  const queryFn: QueryFunction<Awaited<ReturnType<typeof readUsersPositions>>> = ({ signal }) => readUsersPositions({ signal, ...axiosOptions })

  const query = useQuery<Awaited<ReturnType<typeof readUsersPositions>>, TError, TData>(queryKey, queryFn, queryOptions) as UseQueryResult<TData, TError> & { queryKey: QueryKey }

  query.queryKey = queryKey

  return query
}

/**
 * –ü–æ–ª—É—á–µ–Ω–∏–µ —Å–ø–∏—Å–∫–∞ —Å–æ—Ç—Ä—É–¥–Ω–∏–∫–æ–≤
 * @summary –ü–æ–ª—É—á–µ–Ω–∏–µ —Å–ø–∏—Å–∫–∞ —Å–æ—Ç—Ä—É–¥–Ω–∏–∫–æ–≤
 */
export const readUsers = (options?: AxiosRequestConfig): Promise<AxiosResponse<User>> => {
  return axios.get(`/readEmployees`, options)
}

export const getReadUsersQueryKey = () => [`/readEmployees`]

export type ReadUsersQueryResult = NonNullable<Awaited<ReturnType<typeof readUsers>>>
export type ReadUsersQueryError = AxiosError<unknown>

export const useReadUsers = <TData = Awaited<ReturnType<typeof readUsers>>, TError = AxiosError<unknown>>(options?: {
  query?: UseQueryOptions<Awaited<ReturnType<typeof readUsers>>, TError, TData>
  axios?: AxiosRequestConfig
}): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {
  const { query: queryOptions, axios: axiosOptions } = options ?? {}

  const queryKey = queryOptions?.queryKey ?? getReadUsersQueryKey()

  const queryFn: QueryFunction<Awaited<ReturnType<typeof readUsers>>> = ({ signal }) => readUsers({ signal, ...axiosOptions })

  const query = useQuery<Awaited<ReturnType<typeof readUsers>>, TError, TData>(queryKey, queryFn, queryOptions) as UseQueryResult<TData, TError> & { queryKey: QueryKey }

  query.queryKey = queryKey

  return query
}

/**
 * –ü–æ–ª—É—á–µ–Ω–∏–µ —Å–ø–∏—Å–∫–∞ —Ä–∞–±–æ—á–∏—Ö –º–µ—Å—Ç
 * @summary –ü–æ–ª—É—á–µ–Ω–∏–µ —Å–ø–∏—Å–∫–∞ —Ä–∞–±–æ—á–∏—Ö –º–µ—Å—Ç
 */
export const readWorkCenters = (options?: AxiosRequestConfig): Promise<AxiosResponse<Workcenter>> => {
  return axios.get(`/readWorkCenters`, options)
}

export const getReadWorkCentersQueryKey = () => [`/readWorkCenters`]

export type ReadWorkCentersQueryResult = NonNullable<Awaited<ReturnType<typeof readWorkCenters>>>
export type ReadWorkCentersQueryError = AxiosError<unknown>

export const useReadWorkCenters = <TData = Awaited<ReturnType<typeof readWorkCenters>>, TError = AxiosError<unknown>>(options?: {
  query?: UseQueryOptions<Awaited<ReturnType<typeof readWorkCenters>>, TError, TData>
  axios?: AxiosRequestConfig
}): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {
  const { query: queryOptions, axios: axiosOptions } = options ?? {}

  const queryKey = queryOptions?.queryKey ?? getReadWorkCentersQueryKey()

  const queryFn: QueryFunction<Awaited<ReturnType<typeof readWorkCenters>>> = ({ signal }) => readWorkCenters({ signal, ...axiosOptions })

  const query = useQuery<Awaited<ReturnType<typeof readWorkCenters>>, TError, TData>(queryKey, queryFn, queryOptions) as UseQueryResult<TData, TError> & { queryKey: QueryKey }

  query.queryKey = queryKey

  return query
}
